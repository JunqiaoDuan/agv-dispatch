# 任务监控实时路径可视化与自动模拟

## 一、需求概述

在 TaskMonitor 页面中，当小车执行任务时，需要在地图上实时可视化小车的运动轨迹和路径信息。

### 1.1 核心功能

**路径可视化**
- 已走路线：蓝色实线，显示小车已经完成的路径
- 未走路线：灰色虚线，显示小车待完成的路径
- 直达终点线：灰色虚线，从小车当前位置到终点的直线
- 小地图目标点：在缩略图上用圆圈标记任务终点

**实时位置推算**
- 输入数据：任务起点站点、目标站点、进度百分比
- 计算方式：根据路径规划结果和进度百分比推算小车当前位置
- 输出信息：实时坐标(X, Y)、朝向角度

**自动模拟运动**
- 模拟速度：当前小车速度的 60%（可配置常量）
- 模拟机制：收到最新进度后，按配置速度自动向前模拟移动
- 更新策略：下次收到新进度时，跳转到新位置并继续模拟

### 1.2 配置开关

在 TaskMonitorSettingsDialog 中新增配置项：
- **自动模拟运动开关**（默认：开启）
- 自动模拟速度输入框，默认是60（%），可以在前端设置，但不必存入数据库，只对当前页面生效
- 说明文字：开启后，收到最新进度时会按照速度的 60% 自动模拟运动轨迹，直到下一次更新最新位置

## 二、技术方案

### 2.1 数据流

```
AGV 实时进度 (ProgressPercentage)
  ↓
TaskListItemDto
  ↓
TaskMonitor 页面数据刷新
  ↓
路径规划 (AStarPathfinder)
  ↓
位置推算 + 自动模拟器
  ↓
SVG 渲染 (SimulationRenderer)
```

### 2.2 核心组件复用

| 组件 | 用途 | 位置 |
|------|------|------|
| `AStarPathfinder` | 根据起点终点计算完整路径 | AgvDispatch.Shared.PathFinding |
| `AgvSimulator` | 位置计算和模拟逻辑（需修改支持进度跳跃） | AgvDispatch.Shared.Simulation |
| `SimulationRenderer` | 渲染已走路线、未走路线、小车位置 | AgvDispatch.Shared.Rendering |
| `MiniMapRenderer` | 小地图渲染（含目标点标记） | AgvDispatch.Shared.Rendering |

### 2.3 关键实现点

#### 2.3.1 进度驱动的位置计算

```csharp
// 监听任务进度变化
private void OnTaskProgressUpdated(TaskListItemDto task)
{
    if (task.ProgressPercentage.HasValue)
    {
        // 1. 计算路径（如果未计算）
        if (_taskPathCache.TryGetValue(task.Id, out var path))
        {
            // 2. 根据进度百分比计算位置
            var position = CalculatePositionFromProgress(path, task.ProgressPercentage.Value);

            // 3. 更新模拟器位置（跳转）
            _taskSimulators[task.Id].JumpToProgress(task.ProgressPercentage.Value);
        }
    }
}

// 位置计算算法
private AgvPosition CalculatePositionFromProgress(PathfindingResult path, decimal progressPercentage)
{
    // 根据总距离和百分比计算已行驶距离
    decimal targetDistance = path.TotalDistance * (progressPercentage / 100m);

    // 遍历边找到对应位置
    decimal accumulatedDistance = 0;
    foreach (var edge in path.EdgePath)
    {
        if (accumulatedDistance + edge.Distance >= targetDistance)
        {
            // 找到目标边，计算边内进度
            decimal edgeProgress = (targetDistance - accumulatedDistance) / edge.Distance;
            return CalculatePositionOnEdge(edge, edgeProgress);
        }
        accumulatedDistance += edge.Distance;
    }

    // 返回终点位置
    return GetEndPosition(path);
}
```

#### 2.3.2 自动模拟机制

```csharp
// 常量配置
private const decimal SIMULATION_SPEED_RATIO = 0.6m; // 模拟速度为实际速度的 60%

// 定时器更新（50ms 间隔）
private void OnSimulationTimerElapsed()
{
    if (!_enableAutoSimulation) return;

    foreach (var (taskId, simulator) in _taskSimulators)
    {
        if (simulator.State == SimulationState.Running)
        {
            // 使用配置的速度比例进行模拟
            simulator.UpdateWithSpeedRatio(SIMULATION_SPEED_RATIO);

            // 更新渲染
            RenderTaskPath(taskId);
        }
    }
}
```

#### 2.3.3 渲染层次结构

```
地图画布
├── 地图层 (_mapSvg)
│   ├── 网格
│   ├── 边（箭头）
│   ├── 节点
│   └── 站点
│
├── 任务路径层 (_taskPathsSvg)
│   ├── 已走路线（蓝色实线）
│   ├── 未走路线（灰色虚线）
│   └── 直线到终点（灰色虚线）
│
├── AGV 层 (_agvSvg)
│   ├── 小车图标（三角形）
│   ├── 小车编号
│   └── 电量显示
│
└── 小地图
    ├── 地图缩略图
    ├── AGV 位置标记
    ├── 目标点圆圈
    └── 视窗框
```

### 2.4 配置项设计

#### TaskMonitorSettingsDialog.razor

```csharp
// 新增属性
[Parameter]
public bool EnableAutoSimulation { get; set; } = true;

[Parameter]
public EventCallback<bool> OnAutoSimulationChanged { get; set; }

// UI 组件
<MudSwitch T="bool"
           @bind-Value="@LocalEnableAutoSimulation"
           Color="Color.Primary"
           Label="自动模拟运动" />
<MudText Typo="Typo.caption" Color="Color.Secondary">
    开启后，收到最新进度时会按照速度的 60% 自动模拟运动轨迹
</MudText>
```

## 三、参考实现

### 3.1 MapSimulation 页面

TaskMonitor 的实现可以参考 `MapSimulation.razor` 的以下部分：

| 功能 | MapSimulation 实现 | 对应方法/代码位置 |
|------|-------------------|------------------|
| 路径规划 | 手动选择起点终点后计算 | `CalculatePath()` 方法 |
| 位置模拟 | 使用 AgvSimulator 类 | `StartSimulation()`, `OnTimerElapsed()` |
| 渲染逻辑 | SimulationRenderer | `RenderSimulation()` 方法 |
| 小地图 | MiniMapRenderer | `RenderMinimap()` 方法 |
| 追踪模式 | 视图自动跟随小车 | `OnTrackingModeChanged()` |

### 3.2 核心代码参考

**路径规划**（MapSimulation.razor:547-591）
```csharp
private void CalculatePath()
{
    var pathfinder = new AStarPathfinder(_nodes, _edges, _stations);
    _pathResult = pathfinder.FindPath(_startId.Value, _endId.Value);

    if (_pathResult.Success)
    {
        var config = new AgvSimulationConfig { Speed = _speed, UpdateIntervalMs = 50 };
        _simulator = new AgvSimulator(_pathResult, _nodes, _edges, config);
        _simulator.OnPositionUpdated += OnSimulatorPositionUpdated;

        _renderData.HighlightedEdgeIds = _pathResult.EdgePath;
        RenderMap();
    }
}
```

**渲染模拟层**（MapSimulation.razor:685-725）
```csharp
private void RenderSimulation()
{
    _renderData.SimulatedAgvs = [
        new AgvSimulationData
        {
            Position = _simulator.CurrentPosition,
            StartNodeId = _pathResult.NodePath.First(),
            EndNodeId = _pathResult.NodePath.Last(),
            PathEdgeIds = _pathResult.EdgePath,
            Config = new AgvSimulationConfig
            {
                AgvColor = "#2196F3",
                TraveledPathColor = "#2196F3",
                TraveledPathWidth = 3f,
                ToEndLineColor = "#9E9E9E",
                ToEndLineDashArray = "5,5"
            }
        }
    ];

    _simulationSvg = _simulationRenderer.RenderSimulationLayer(
        _renderData, _viewWidth, _viewHeight, _scale, _offsetX, _offsetY,
        elementScale: _elementScale);
}
```

## 四、实现差异对比

| 对比项 | MapSimulation（现有） | TaskMonitor（新需求） |
|--------|----------------------|---------------------|
| **数据源** | 手动选择起点终点 | 从任务数据自动获取（TaskListItemDto） |
| **进度控制** | 完全自主模拟，从 0% 到 100% | 以实际进度为准 + 自动补间模拟 |
| **速度设置** | 用户手动调整滑块 | 使用固定比例（实际速度 × 60%） |
| **启动方式** | 手动点击"开始"按钮 | 检测到任务状态为 Executing 时自动开启 |
| **进度更新** | 持续递增，不会跳跃 | 可能跳跃（收到新的进度百分比时） |
| **多任务支持** | 单一模拟 | 支持多个任务同时执行和显示 |
| **配置开关** | 无需配置 | 提供"自动模拟"开关 |

## 五、实现步骤

### 5.1 数据层
1. 扩展任务数据监听，获取 `ProgressPercentage` 变化
2. 为每个执行中的任务创建路径规划缓存
3. 创建任务模拟器字典，管理多个并行任务

### 5.2 模拟层
1. 修改 `AgvSimulator` 支持进度跳跃（`JumpToProgress` 方法）
2. 实现基于速度比例的更新逻辑
3. 添加定时器管理自动模拟

### 5.3 渲染层
1. 在 TaskMonitor 中添加 `_taskPathsSvg` 渲染层
2. 复用 `SimulationRenderer` 渲染已走/未走路线
3. 更新小地图渲染逻辑，添加目标点圆圈

### 5.4 配置层
1. 在 `TaskMonitorSettingsDialog` 添加自动模拟开关
2. 添加 `SIMULATION_SPEED_RATIO` 常量配置
3. 实现配置持久化（可选）

### 5.5 UI 层
1. 调整 CSS 样式确保多层正确叠加
2. 优化性能，避免频繁重绘整个地图
3. 添加任务选择高亮功能（可选）

## 六、关键注意事项

1. **性能优化**
   - 只为执行中的任务创建模拟器
   - 任务完成后及时清理模拟器资源
   - 避免每次刷新都重新计算路径（使用缓存）

2. **进度跳跃处理**
   - AGV 实际进度可能因为网络延迟出现非连续更新
   - 模拟器需要支持直接跳转到新的进度位置
   - 跳转后继续从新位置进行自动模拟

3. **多任务并发**
   - 支持多个任务同时执行
   - 每个任务独立的模拟器和渲染状态
   - 合理管理内存，避免任务过多导致性能问题

4. **用户体验**
   - 提供清晰的视觉反馈（已走/未走路线颜色区分）
   - 小地图同步显示目标点位置
   - 支持关闭自动模拟（配置开关）

## 七、验收标准

1. ✅ 执行中的任务在地图上显示完整路径（已走 + 未走）
2. ✅ 小车位置根据进度百分比实时计算并显示
3. ✅ 自动模拟功能正常运行，速度为实际速度的 60%
4. ✅ 收到新进度时，小车位置能正确跳转并继续模拟
5. ✅ 小地图上显示任务目标点圆圈标记
6. ✅ 配置开关能正常启用/禁用自动模拟功能
7. ✅ 支持多个任务同时执行时的正确渲染
8. ✅ 任务完成后，路径和小车正确消失

---

**文档版本**: v1.0
**创建日期**: 2026-01-20
**相关页面**: TaskMonitor.razor, TaskMonitorSettingsDialog.razor
**参考实现**: MapSimulation.razor

# AGV调度系统技术方案

> 版本: v1.7
> 日期: 2026-01-17
> 状态: 待评审

---

## 一、项目概述

### 1.1 项目背景

建设一套AGV小车调度系统，实现对3辆AGV小车的统一调度管理。系统包含中央调度服务、现场调度界面、移动端APP三个主要组成部分。

### 1.2 系统架构总览

```
┌──────────────────────────────────────────────────────────────────────────┐
│                              阿里云服务器                                  │
│                                                                          │
│  ┌────────────────────────────────────────────────────────────────────┐  │
│  │                  AGV中央调度服务 (ASP.NET Core 8)                   │  │
│  │  ┌──────────────┐  ┌──────────────┐  ┌────────────────────────┐   │  │
│  │  │   REST API   │  │ 内嵌 MQTT    │  │       调度引擎          │   │  │
│  │  │  Web/APP调用  │  │ Broker:1883  │  │   任务分配/路线选择     │   │  │
│  │  └──────┬───────┘  └──────┬───────┘  └────────────────────────┘   │  │
│  │         │                 │                                        │  │
│  │  ┌──────┴─────────────────┴───────────────────────────────────┐   │  │
│  │  │                        数据库                               │   │  │
│  │  └────────────────────────────────────────────────────────────┘   │  │
│  └────────────────────────────────────────────────────────────────────┘  │
│         ▲                    │                                           │
│         │ HTTP               │ MQTT                                      │
│         │                    ▼                                           │
└─────────┼────────────────────┼───────────────────────────────────────────┘
          │                    │
          │            ┌───────┴───────┐
          │            │   AGV小车x3   │
          │            │   (树莓派)    │
          │            │   硬件团队    │
          │            └───────────────┘
          │
    ┌─────┴─────────────────────┐
    │ HTTP (轮询)               │ HTTP (轮询)
    ▼                           ▼
┌───────────────┐        ┌───────────────┐
│  现场调度界面  │        │   安卓APP     │
│  (Blazor Web) │        │  (Avalonia)   │
│   软件团队     │        │   软件团队    │
└───────────────┘        └───────────────┘
```

### 1.3 通信方式分工

| 终端 | 协议 | 用途 |
|------|------|------|
| **AGV小车** | MQTT | 实时双向通信：状态上报、接收任务/指令 |
| **Web界面** | HTTP | 查询数据、创建任务、轮询状态 |
| **安卓APP** | HTTP | 查询数据、创建任务、轮询状态 |

### 1.4 选择 MQTT 的原因（小车通信）

- **IoT 领域标准协议**：硬件团队熟悉，有成熟的客户端库
- **内置可靠性**：QoS 机制保证消息不丢失
- **断线重连**：协议层支持，无需额外开发
- **离线消息**：小车离线期间的任务可暂存，上线后自动推送
- **弱网友好**：专为不稳定网络设计，适合工厂环境
- **低带宽**：协议头仅 2 字节，适合嵌入式设备

---

## 二、团队分工

### 2.1 软件团队职责

| 模块 | 说明 | 交付物 |
|------|------|--------|
| 中央调度服务 | 部署于阿里云，内嵌 MQTT Broker，提供调度核心逻辑 | 可部署的服务程序 |
| 现场调度界面 | Web应用，用于现场操作人员使用 | Blazor Web应用 |
| 安卓APP | 移动端应用，用于移动查看和操作 | APK安装包 |
| 通信协议 | 定义 MQTT Topic 和消息格式 | 协议文档 + 示例代码 |
| 模拟器 | 用于联调的小车模拟程序 | 控制台模拟程序 |

### 2.2 硬件团队职责

| 模块 | 说明 | 交付物 |
|------|------|--------|
| 小车控制程序 | 运行于树莓派，控制小车运动 | 树莓派程序 |
| MQTT 客户端 | 对接 MQTT Broker，收发消息 | 集成到控制程序 |
| 避障系统 | 传感器数据处理与避障逻辑 | 集成到控制程序 |
| 路线执行 | 按服务器下发的路线行驶 | 集成到控制程序 |

### 2.3 职责边界

```
┌─────────────────────────────────────────────────────────────────┐
│                        软件团队负责                              │
├─────────────────────────────────────────────────────────────────┤
│  • 中央调度服务（内嵌 MQTT Broker）                              │
│  • 任务创建、分配、调度                                          │
│  • 路线选择（选择哪辆车走哪条路线）                               │
│  • 小车状态监控与展示                                            │
│  • 历史记录存储与查询                                            │
│  • 提供通信协议及对接支持                                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ MQTT 协议
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        硬件团队负责                              │
├─────────────────────────────────────────────────────────────────┤
│  • 连接 MQTT Broker，订阅/发布相关 Topic                        │
│  • 上报小车状态（位置、电量、运行状态）                           │
│  • 接收并执行任务指令                                            │
│  • 路线执行（按路径点行驶）                                      │
│  • 避障处理（传感器检测 + 停车/绕障）                            │
│  • 异常上报（故障、急停等）                                      │
└─────────────────────────────────────────────────────────────────┘
```

### 2.4 协作流程

```
阶段1: 协议确认
  软件团队 ──提供协议文档──▶ 硬件团队
  硬件团队 ──确认/反馈────▶ 软件团队
  双方 ────── 协议定稿 ──────

阶段2: 并行开发
  软件团队: 部署Broker + 开发服务器 + 界面 + 模拟器
  硬件团队: 开发小车控制程序

阶段3: 联调测试
  软件团队 ──提供测试环境──▶ 硬件团队
  双方 ────── 联调对接 ──────

阶段4: 现场部署
  双方 ────── 现场调试 ──────
```

---

## 三、通信协议规范

### 3.1 通信方式

- **协议**: MQTT v5.0
- **数据格式**: JSON
- **编码**: UTF-8

### 3.2 连接信息（小车 → MQTT Broker）

| 环境 | 地址 | 端口 |
|------|------|------|
| 生产环境 | {服务器域名} | 1883 (TCP) / 8883 (TLS) |
| 测试环境 | {服务器IP} | 1883 (TCP) |

### 3.3 连接认证

| 参数 | 说明 |
|------|------|
| Client ID | 小车编码（如 `V001`），**必须与 Username 一致** |
| Username | 小车编码（如 `V001`），**必须与 Client ID 一致** |
| Password | 认证密码，由软件团队预先分配并存储在数据库中 |
| Clean Session | `false`（保留会话，支持离线消息） |

**重要说明：**
- 服务器端会验证 ClientId 和 Username 是否一致，不一致将拒绝连接
- Password 使用数据库中存储的小车密码进行验证（支持密码哈希）

### 3.4 QoS 级别说明

| QoS | 含义 | 使用场景 |
|-----|------|----------|
| 0 | 最多一次，可能丢失 | 心跳、高频状态上报 |
| 1 | 至少一次，确保送达 | 任务下发、异常上报 |
| 2 | 恰好一次，不重复 | 暂不使用 |

### 3.5 心跳机制

- **Keep Alive**: 60 秒（MQTT 协议层心跳，客户端库自动处理）
- **状态上报**: 每 5 秒发布一次状态消息
- **离线检测**: 服务器记录每辆车最后上报时间，超过 15 秒未收到状态则标记为离线

---

## 四、Topic 设计

### 4.1 Topic 结构

**AGV → 服务器 (上行)：**
```
agv/{agvCode}/status              # 状态上报 (心跳,1-5秒)
agv/{agvCode}/task/progress       # 任务进度上报 (状态变化时)
agv/{agvCode}/path/lock-request   # 路段锁定请求 (到达中间点前)
agv/{agvCode}/path/unlock         # 路段解锁通知 (离开路段后)
agv/{agvCode}/exception           # 异常上报
```

**服务器 → AGV (下行)：**
```
agv/{agvCode}/task/assign         # 任务下发 (工人确认后立即发送)
agv/{agvCode}/task/cancel         # 任务取消
agv/{agvCode}/path/lock-response  # 路段锁定响应 (批准/拒绝)
agv/{agvCode}/command             # 控制指令 (暂停/继续/急停)
```

### 4.2 Topic 订阅关系

**小车端订阅：**
```
agv/{自己的agvCode}/task/assign        # QoS 1
agv/{自己的agvCode}/task/cancel        # QoS 1
agv/{自己的agvCode}/path/lock-response # QoS 1
agv/{自己的agvCode}/command            # QoS 1
```

**服务器订阅：**
```
agv/+/status              # 所有小车状态
agv/+/task/progress       # 所有任务进度
agv/+/path/lock-request   # 所有路段锁定请求
agv/+/path/unlock         # 所有路段解锁通知
agv/+/exception           # 所有异常
```

**说明：** 内嵌MQTT Broker无需显式订阅Topic，所有消息通过 `InterceptingPublishAsync` 事件统一拦截处理。

### 4.3 Topic 与 QoS 对照表

| Topic | 方向 | QoS | Retain | 说明 |
|-------|------|-----|--------|------|
| `agv/{agvCode}/status` | 小车→服务器 | 0 | false | 状态上报 |
| `agv/{agvCode}/task/assign` | 服务器→小车 | 1 | false | 任务必达 |
| `agv/{agvCode}/task/cancel` | 服务器→小车 | 1 | false | 取消必达 |
| `agv/{agvCode}/task/progress` | 小车→服务器 | 1 | false | 进度必达 |
| `agv/{agvCode}/command` | 服务器→小车 | 1 | false | 指令必达 |
| `agv/{agvCode}/exception` | 小车→服务器 | 1 | false | 异常必达 |
| `agv/{agvCode}/path/lock-request` | 小车→服务器 | 1 | false | 锁定请求必达 |
| `agv/{agvCode}/path/lock-response` | 服务器→小车 | 1 | false | 锁定响应必达 |
| `agv/{agvCode}/path/unlock` | 小车→服务器 | 1 | false | 解锁通知必达 |

**注意：**
- 服务器端发送的所有消息统一使用 QoS=1 (AtLeastOnce)，Retain=false
- 小车端建议对关键消息（任务进度、异常、路径锁定）使用 QoS=1，状态消息可使用 QoS=0 以减少网络开销

---

## 五、消息格式定义

### 5.1 枚举定义

```csharp
// 小车运行状态
public enum AgvStatus
{
    Offline = 0,      // 离线
    Idle = 10,        // 空闲
    Running = 20,     // 执行任务中
    Charging = 30,    // 充电中
    Error = 90        // 故障
}

// 任务状态
public enum TaskStatus
{
    Pending = 0,      // 待分配
    Assigned = 10,    // 已分配（已下发，待执行）
    Executing = 20,   // 执行中
    Completed = 30,   // 已完成
    Cancelled = 40,   // 已取消
    Failed = 50       // 失败
}

// 任务类型
public enum TaskType
{
    Transport = 10,   // 搬运任务
    Charge = 20,      // 充电任务
    Return = 30       // 返回待命点
}

// 控制指令类型
public enum CommandType
{
    Pause = 30,       // 暂停
    Resume = 31       // 继续
}

// 异常类型
public enum AgvExceptionType
{
    ObstacleDetected = 10,  // 检测到障碍物
    LowBattery = 20,        // 低电量
    NetworkError = 30,      // 网络异常
    GpsError = 31,          // GPS信号异常
    EmergencyStop = 40,     // 急停按钮触发
    Other = 80              // 其他
}

// 异常严重级别
public enum AgvExceptionSeverity
{
    Info = 10,        // 提示信息
    Warning = 20,     // 警告（可自动恢复）
    Error = 30,       // 错误（需人工干预）
    Critical = 40     // 严重故障
}
```

---

### 5.2 消息详细定义

#### 5.2.1 状态上报 (agv/{agvCode}/status)

小车定时（每5秒）或状态变化时发布。

**Payload:**
```json
{
  "agvCode": "V001",
  "timestamp": "2026-01-04T10:00:05Z",
  "status": 20,
  "battery": 85,
  "speed": 0.5,
  "position": {
    "x": 100.5,
    "y": 200.3,
    "angle": 90.0,
    "stationId": null
  },
  "currentTaskId": "TASK001",
  "errorCode": null,
  "message": null
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| agvCode | string | 小车编码，如 V001 |
| timestamp | string | 时间戳 (ISO 8601 格式) |
| status | int | AgvStatus 枚举值（Offline=0, Idle=10, Running=20, Charging=30, Error=90） |
| battery | int | 电量百分比 (0-100) |
| speed | double | 当前速度 (m/s) |
| position.x | double? | X坐标 (厘米)，可为null |
| position.y | double? | Y坐标 (厘米)，可为null |
| position.angle | double? | 朝向角度 (0-360度，正东为0)，可为null |
| position.stationId | string? | 当前站点ID，不在站点时为null |
| currentTaskId | string? | 当前任务ID，无任务时为null |
| errorCode | string? | 错误码，正常时为null |
| message | string? | 消息描述，正常时为null |

---

#### 5.2.2 任务下发 (agv/{agvCode}/task/assign)

服务器向小车下发任务。

**Payload:**
```json
{
  "taskId": "TASK001",
  "taskType": 10,
  "priority": 30,
  "timestamp": "2026-01-04T10:00:00Z",
  "startStationCode": "S001",
  "endStationCode": "S002",
  "description": "从S001运送到S002"
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| taskId | string | 任务ID |
| taskType | int | TaskType 枚举值（Transport=10, Charge=20, Return=30） |
| priority | int | 优先级，数值越大优先级越低（有效值：10、20、30、40、50，默认30） |
| timestamp | string | 时间戳 (ISO 8601 格式) |
| startStationCode | string | 起点站点编号，如 S001 |
| endStationCode | string | 终点站点编号，如 S002 |
| description | string? | 任务描述 |

**说明：**
- 实际实现中不包含路径点（waypoints）数组，小车根据起点、终点自行规划路径
- 优先级数值越大，优先级越低（30为默认值，10为最高优先级）

---

#### 5.2.3 任务进度 (agv/{agvCode}/task/progress)

小车上报任务执行进度。

**Payload:**
```json
{
  "agvCode": "V001",
  "taskId": "TASK001",
  "timestamp": "2026-01-04T10:05:00Z",
  "status": 20,
  "progressPercentage": 50.0,
  "message": "正在前往目标站点"
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| agvCode | string | 小车编码 |
| taskId | string | 任务ID |
| timestamp | string | 时间戳 (ISO 8601 格式) |
| status | int | TaskStatus 枚举值（Pending=0, Assigned=10, Executing=20, Completed=30, Cancelled=40, Failed=50） |
| progressPercentage | double? | 进度百分比 (0-100)，可为null |
| message | string? | 进度消息描述 |

**状态触发时机：**

| status值 | 说明 | 触发时机 |
|----------|------|----------|
| 10 (Assigned) | 已分配 | 收到任务，准备执行 |
| 20 (Executing) | 执行中 | 开始执行 / 任务进行中 |
| 30 (Completed) | 已完成 | 任务完成 |
| 40 (Cancelled) | 已取消 | 收到取消指令后确认 |
| 50 (Failed) | 失败 | 任务执行失败 |

---

#### 5.2.4 取消任务 (agv/{agvCode}/task/cancel)

服务器通知小车取消任务。

**Payload:**
```json
{
  "taskId": "TASK001",
  "timestamp": "2026-01-04T10:10:00Z",
  "reason": "用户取消"
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| taskId | string | 任务ID |
| timestamp | string | 时间戳 (ISO 8601 格式) |
| reason | string? | 取消原因 |

**小车收到后的处理流程：**

1. 小车收到取消指令
2. 停止当前任务执行
3. 通过 `task/progress` 上报取消确认（status=40）

**确认消息示例：**
```json
{
  "agvCode": "V001",
  "taskId": "TASK001",
  "timestamp": "2026-01-04T10:10:01Z",
  "status": 40,
  "progressPercentage": null,
  "message": "任务已取消"
}
```

---

#### 5.2.5 控制指令 (agv/{agvCode}/command)

服务器向小车下发控制指令。

**Payload:**
```json
{
  "commandId": "CMD001",
  "commandType": 30,
  "timestamp": "2026-01-04T10:10:00Z",
  "params": {}
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| commandId | string | 指令ID |
| commandType | int | CommandType 枚举值（Pause=30, Resume=31） |
| timestamp | string | 时间戳 (ISO 8601 格式) |
| params | object? | 指令参数字典，可为null或空对象 |

**支持的指令类型：**

| commandType | 说明 | params |
|-------------|------|--------|
| 30 | Pause - 暂停 | {} |
| 31 | Resume - 继续 | {} |

**说明：**
- 当前版本仅支持暂停和继续指令
- 小车收到指令后应立即执行，并通过状态上报消息(status)反馈执行结果
- params字段为预留的扩展参数，当前可传空对象

---

#### 5.2.6 异常上报 (agv/{agvCode}/exception)

小车发生异常时上报。

**Payload:**
```json
{
  "agvCode": "V001",
  "timestamp": "2026-01-04T10:05:30Z",
  "exceptionType": 10,
  "severity": 20,
  "message": "前方检测到障碍物，已暂停",
  "position": {
    "x": 150.0,
    "y": 220.5,
    "angle": 90.0,
    "stationId": null
  },
  "taskId": "TASK001"
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| agvCode | string | 小车编码 |
| timestamp | string | 时间戳 (ISO 8601 格式) |
| exceptionType | int | AgvExceptionType 枚举值 |
| severity | int | AgvExceptionSeverity 枚举值 |
| message | string? | 异常消息描述 |
| position | object? | 发生异常时的位置信息，可为null |
| taskId | string? | 当前任务ID，无任务时为null |

**异常类型 (AgvExceptionType)：**

| 值 | 名称 | 说明 |
|----|------|------|
| 10 | ObstacleDetected | 检测到障碍物 |
| 20 | LowBattery | 低电量 |
| 30 | NetworkError | 网络异常 |
| 31 | GpsError | GPS信号异常 |
| 40 | EmergencyStop | 急停按钮触发 |
| 80 | Other | 其他异常 |

**严重级别 (AgvExceptionSeverity)：**

| 值 | 名称 | 说明 |
|----|------|------|
| 10 | Info | 提示信息 |
| 20 | Warning | 警告（可自动恢复） |
| 30 | Error | 错误（需人工干预） |
| 40 | Critical | 严重故障 |

---

#### 5.2.7 路段锁定请求 (agv/{agvCode}/path/lock-request)

**Topic**: `agv/{agvCode}/path/lock-request`
**QoS**: 1 (至少一次)
**触发时机**: AGV即将到达中间点时 (距离约5米)

**Payload:**
```json
{
  "agvCode": "V001",
  "taskId": "T001",
  "timestamp": "2026-01-17T10:05:00Z",
  "fromStationCode": "S002",
  "toStationCode": "S003"
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| agvCode | string | 小车编码 |
| taskId | string | 当前任务编号 |
| timestamp | string | 时间戳 (ISO 8601 格式) |
| fromStationCode | string | 起始站点 (当前中间点) |
| toStationCode | string | 目标站点 (下一个中间点或终点) |

---

#### 5.2.8 路段锁定响应 (agv/{agvCode}/path/lock-response)

**Topic**: `agv/{agvCode}/path/lock-response`
**QoS**: 1 (至少一次)
**触发时机**: 服务器收到锁定请求后立即响应

**Payload (批准):**
```json
{
  "agvCode": "V001",
  "taskId": "T001",
  "timestamp": "2026-01-17T10:05:01Z",
  "fromStationCode": "S002",
  "toStationCode": "S003",
  "status": 10,
  "message": "路段已锁定，允许通过"
}
```

**Payload (拒绝):**
```json
{
  "agvCode": "V001",
  "taskId": "T001",
  "timestamp": "2026-01-17T10:05:01Z",
  "fromStationCode": "S002",
  "toStationCode": "S003",
  "status": 20,
  "message": "路段被占用，请等待",
  "lockedByAgvCode": "V002"
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| agvCode | string | 小车编码 |
| taskId | string | 任务编号 |
| timestamp | string | 时间戳 (ISO 8601 格式) |
| fromStationCode | string | 起始站点 |
| toStationCode | string | 目标站点 |
| status | int | 响应状态枚举：Approved (10) - 已批准，Rejected (20) - 已拒绝 |
| message | string | 响应消息 |
| lockedByAgvCode | string? | 如果被拒绝，返回占用该路段的小车编号 (可选) |

---

#### 5.2.9 路段解锁通知 (agv/{agvCode}/path/unlock)

**Topic**: `agv/{agvCode}/path/unlock`
**QoS**: 1 (至少一次)
**触发时机**: AGV离开路段时 (可选，也可以在申请下一段时自动释放上一段)

**Payload:**
```json
{
  "agvCode": "V001",
  "taskId": "T001",
  "timestamp": "2026-01-17T10:06:00Z",
  "fromStationCode": "S002",
  "toStationCode": "S003"
}
```

| 字段 | 类型 | 说明 |
|------|------|------|
| agvCode | string | 小车编码 |
| taskId | string | 任务编号 |
| timestamp | string | 时间戳 (ISO 8601 格式) |
| fromStationCode | string | 起始站点 |
| toStationCode | string | 目标站点 |

---

### 5.3 通信时序图

#### 正常任务流程

```
小车                     MQTT Broker                   服务器
  │                           │                          │
  │ ══ CONNECT ══════════════▶│                          │
  │    ClientId=V001        │                          │
  │    Username=V001        │                          │
  │    Password=***           │                          │
  │                           │─ 验证身份 ──────────────▶│
  │ ◀════ CONNACK ═══════════ │                          │
  │    (认证成功)              │                          │
  │                           │                          │
  │ ── SUBSCRIBE ───────────▶ │                          │
  │    agv/V001/task/assign │                          │
  │    agv/V001/task/cancel │                          │
  │    agv/V001/command     │                          │
  │                           │                          │
  │ ── PUBLISH ─────────────▶ │ ── 拦截转发 ───────────▶ │
  │    agv/V001/status      │    (status: Idle=10)     │
  │    QoS=0                  │                          │
  │                           │                          │
  │                           │ ◀── PUBLISH ──────────── │
  │ ◀── 转发 ──────────────── │    agv/V001/task/assign│
  │    (任务下发)              │    QoS=1                 │
  │                           │                          │
  │ ── PUBLISH ─────────────▶ │ ── 拦截转发 ───────────▶ │
  │    agv/V001/task/progress│   (status: Assigned=10) │
  │    QoS=1                  │                          │
  │                           │                          │
  │ ── PUBLISH ─────────────▶ │ ── 拦截转发 ───────────▶ │
  │    agv/V001/status      │    (status: Running=20)  │
  │                           │                          │
  │         ... 执行任务 ...   │                          │
  │    (每5秒上报一次状态)     │                          │
  │                           │                          │
  │ ── PUBLISH ─────────────▶ │ ── 拦截转发 ───────────▶ │
  │    agv/V001/task/progress│   (status: Completed=30)│
  │    QoS=1                  │                          │
  │                           │                          │
  │ ── PUBLISH ─────────────▶ │ ── 拦截转发 ───────────▶ │
  │    agv/V001/status      │    (status: Idle=10)     │
  │                           │                          │
```

#### 异常处理流程

```
小车                     MQTT Broker                   服务器
  │                           │                          │
  │   检测到障碍物             │                          │
  │                           │                          │
  │ ── PUBLISH ─────────────▶ │ ── 拦截转发 ───────────▶ │
  │    agv/V001/exception   │  (exceptionType=10,      │
  │    QoS=1                  │   severity=20)           │
  │                           │                          │
  │ ── PUBLISH ─────────────▶ │ ── 拦截转发 ───────────▶ │
  │    agv/V001/status      │    (status: Error=90)    │
  │                           │                          │
```

#### 取消任务流程

```
小车                     MQTT Broker                   服务器
  │                           │                          │
  │   正在执行任务             │                          │
  │                           │                          │
  │                           │ ◀── PUBLISH ──────────── │
  │ ◀── 转发 ──────────────── │    agv/V001/task/cancel│
  │    (取消任务)              │    QoS=1                 │
  │                           │                          │
  │   停止任务                 │                          │
  │                           │                          │
  │ ── PUBLISH ─────────────▶ │ ── 拦截转发 ───────────▶ │
  │    agv/V001/task/progress│   (status: Cancelled=40)│
  │    QoS=1                  │                          │
  │                           │                          │
  │ ── PUBLISH ─────────────▶ │ ── 拦截转发 ───────────▶ │
  │    agv/V001/status      │    (status: Idle=10)     │
  │                           │                          │
```

**说明：**
- 内嵌MQTT Broker通过 `InterceptingPublishAsync` 事件拦截所有消息，无需显式订阅
- 服务器端发送的所有消息统一使用 QoS=1，保证消息必达
- 小车端建议状态消息使用 QoS=0，其他消息使用 QoS=1

---

## 六、HTTP API 接口设计

Web 界面和安卓 APP 通过 HTTP API 与服务器交互。

### 6.1 接口规范

- **协议**: HTTPS
- **数据格式**: JSON
- **认证方式**: JWT Token (Header: `Authorization: Bearer {token}`)
- **基础路径**: `/api`

### 6.2 接口列表

#### 6.2.1 小车相关

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/agvs` | 获取所有小车状态 |
| GET | `/api/agvs/{id}` | 获取单个小车详情 |
| POST | `/api/agvs/{id}/command` | 下发控制指令（暂停/继续/急停） |

**GET /api/agvs 响应示例：**
```json
{
  "data": [
    {
      "id": "V001",
      "name": "1号车",
      "status": 1,
      "statusText": "空闲",
      "battery": 85,
      "position": { "x": 100.5, "y": 200.3, "angle": 90.0 },
      "currentTaskId": null,
      "lastOnline": "2026-01-04T10:00:00Z"
    }
  ],
  "timestamp": "2026-01-04T10:00:05Z"
}
```

**POST /api/agvs/{id}/command 请求示例：**
```json
{
  "commandType": 1,
  "params": {}
}
```

#### 6.2.2 任务相关

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/tasks` | 获取任务列表（支持分页、筛选） |
| GET | `/api/tasks/{id}` | 获取任务详情 |
| POST | `/api/tasks` | 创建任务 |
| DELETE | `/api/tasks/{id}` | 取消任务 |

**POST /api/tasks 请求示例：**
```json
{
  "taskType": 1,
  "routeId": "R001",
  "priority": 1,
  "description": "从A点运送到B点"
}
```

**响应示例：**
```json
{
  "taskId": "TASK001",
  "status": 0,
  "message": "任务已创建，等待分配"
}
```

#### 6.2.3 路线/站点相关

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/stations` | 获取所有站点 |
| POST | `/api/stations` | 创建站点 |
| PUT | `/api/stations/{id}` | 更新站点 |
| DELETE | `/api/stations/{id}` | 删除站点 |
| GET | `/api/routes` | 获取所有路线 |
| POST | `/api/routes` | 创建路线 |
| PUT | `/api/routes/{id}` | 更新路线 |
| DELETE | `/api/routes/{id}` | 删除路线 |

#### 6.2.4 历史记录

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | `/api/tasks/history` | 任务历史（支持分页、时间筛选） |
| GET | `/api/exceptions` | 异常记录 |

### 6.3 状态轮询

Web/APP 通过定时轮询获取小车实时状态：

```javascript
// 推荐轮询间隔：2秒
setInterval(async () => {
  const response = await fetch('/api/agvs');
  const data = await response.json();
  updateDashboard(data);
}, 2000);
```

### 6.4 错误响应格式

```json
{
  "error": {
    "code": "E001",
    "message": "小车离线"
  }
}
```

---

## 七、软件技术选型

### 7.1 技术栈

| 层级 | 技术选型 | 版本 | 说明 |
|------|----------|------|------|
| 后端框架 | ASP.NET Core | 8.0 | 跨平台，性能优秀 |
| MQTT 客户端 | MQTTnet | 4.x | .NET 首选 MQTT 库 |
| ORM | Entity Framework Core | 8.0 | 代码优先，迁移方便 |
| 数据库 | PostgreSQL | 15+ | 开源，稳定可靠 |
| 缓存 | 内存缓存 | - | 小规模暂不需要Redis |
| 现场界面 | Blazor Server | 8.0 | .NET全栈，共享模型 |
| 移动端 | Avalonia UI | 11.x | 跨平台，自绘引擎，稳定性好 |
| 日志 | Serilog | 3.x | 结构化日志 |
| API文档 | Swagger/OpenAPI | - | 自动生成文档 |

### 7.2 项目结构

```
agv-dispatch/
│
├── src/
│   │
│   ├── AgvDispatch.Shared/              # 共享类库
│   │   ├── Models/                      # 数据模型
│   │   │   ├── Agv.cs
│   │   │   ├── AgvTask.cs
│   │   │   ├── Route.cs
│   │   │   └── Station.cs
│   │   ├── Messages/                    # MQTT 消息定义
│   │   │   ├── StatusMessage.cs
│   │   │   ├── TaskAssignMessage.cs
│   │   │   ├── TaskProgressMessage.cs
│   │   │   ├── CommandMessage.cs
│   │   │   └── ExceptionMessage.cs
│   │   ├── Enums/
│   │   │   ├── AgvStatus.cs
│   │   │   ├── TaskStatus.cs
│   │   │   └── CommandType.cs
│   │   └── Constants/
│   │       └── MqttTopics.cs            # Topic 常量定义
│   │
│   ├── AgvDispatch.Business/            # 业务层（核心业务逻辑）
│   │   ├── Services/                    # 业务服务
│   │   │   ├── IDispatchService.cs      # 调度服务接口
│   │   │   ├── DispatchService.cs       # 调度算法、任务分配规则
│   │   │   ├── ITaskBusinessService.cs
│   │   │   ├── TaskBusinessService.cs   # 任务业务规则
│   │   │   ├── IRoutePlanningService.cs
│   │   │   └── RoutePlanningService.cs  # 路线规划逻辑
│   │   └── Interfaces/                  # 业务接口定义
│   │
│   ├── AgvDispatch.Host/              # 中央调度服务
│   │   ├── Program.cs
│   │   ├── appsettings.json
│   │   ├── Mqtt/                        # 内嵌 MQTT Broker
│   │   │   ├── MqttBrokerService.cs     # Broker 托管服务
│   │   │   └── MqttMessageHandler.cs    # 消息处理器
│   │   ├── Controllers/                 # HTTP API (供 Web/APP 调用)
│   │   │   ├── AgvsController.cs        # GET/POST /api/agvs
│   │   │   ├── TasksController.cs       # GET/POST/DELETE /api/tasks
│   │   │   ├── StationsController.cs    # GET/POST/PUT/DELETE /api/stations
│   │   │   └── RoutesController.cs      # GET/POST/PUT/DELETE /api/routes
│   │   ├── Application/                 # 应用服务层（协调层）
│   │   │   ├── Services/                # 应用服务
│   │   │   │   ├── AgvApplicationService.cs    # 协调业务层和数据层，处理小车相关操作
│   │   │   │   ├── TaskApplicationService.cs   # 协调任务创建、分配、保存的完整流程
│   │   │   │   └── DispatchApplicationService.cs # 协调调度流程（读取数据→调用业务逻辑→保存结果→发送消息）
│   │   │   └── DTOs/                    # 数据传输对象（Controller 和 Service 之间传递的数据）
│   │   ├── Infrastructure/             # 基础设施层（技术实现）
│   │   │   └── Messaging/               # 消息处理（MQTT 消息发送、接收的封装）
│   │   └── Data/                        # 数据层（数据库操作）
│   │       ├── AppDbContext.cs         # EF Core 数据库上下文
│   │       ├── Entities/                # 数据库实体（对应数据库表）
│   │       └── Repositories/           # 数据访问接口和实现（封装数据库操作）
│   │
│   ├── AgvDispatch.Web/                 # 现场调度界面 (Blazor)
│   │   ├── Program.cs
│   │   ├── Components/
│   │   │   ├── Pages/
│   │   │   │   ├── Dashboard.razor      # 监控大屏
│   │   │   │   ├── TaskManage.razor     # 任务管理
│   │   │   │   └── AgvMonitor.razor     # 小车监控
│   │   │   └── Shared/
│   │   └── wwwroot/
│   │
│   ├── AgvDispatch.Mobile/              # 安卓APP (Avalonia)
│   │   ├── Program.cs
│   │   ├── App.axaml                    # Avalonia 应用入口
│   │   ├── Views/
│   │   ├── ViewModels/
│   │   └── Services/
│   │
│   └── AgvDispatch.Simulator/           # 小车模拟器 (联调用)
│       ├── Program.cs
│       └── AgvSimulator.cs
│
├── tests/
│   ├── AgvDispatch.Host.Tests/
│   └── AgvDispatch.Shared.Tests/
│
├── docs/
│   ├── technical-design.md              # 本文档
│   └── api-reference.md                 # API参考
│
└── AgvDispatch.sln                      # 解决方案文件
```

**说明**：
- **代码结构分离**：`AgvDispatch.Host` 和 `AgvDispatch.Web` 在代码层面是分开的项目，便于模块化管理和职责分离
- **部署时集成**：`AgvDispatch.Web` 作为 Blazor Server 应用，通过项目引用集成到 `AgvDispatch.Host` 中，最终打包成一个服务部署
- **实际部署**：只需要部署一个服务（`agv-dispatch`），该服务同时提供：
  - MQTT Broker（端口 1883/8883）
  - REST API（端口 443，供 Web/APP 调用）
  - Blazor Web 界面（端口 443，通过 SignalR 实时通信）

**项目引用关系**：
```
AgvDispatch.Host (主项目，启动入口)
  ├── 引用 AgvDispatch.Business (业务层)
  ├── 引用 AgvDispatch.Shared (共享类库)
  └── 引用 AgvDispatch.Web (Blazor 组件库)

AgvDispatch.Business (业务层)
  └── 引用 AgvDispatch.Shared (共享类库)
```

**分层架构说明**：

| 层级 | 项目/目录 | 职责 | 依赖关系 |
|------|----------|------|----------|
| **表现层** | `Controllers/` | 接收 HTTP 请求，参数验证，调用应用服务 | 依赖 Application |
| **应用服务层** | `Application/` | 协调业务逻辑、数据访问、基础设施，处理事务边界 | 依赖 Business、Data、Infrastructure |
| **业务层** | `AgvDispatch.Business/` | 核心业务规则、算法、领域逻辑（纯业务，不依赖基础设施） | 仅依赖 Shared |
| **基础设施层** | `Infrastructure/`, `Mqtt/` | 技术实现：MQTT、缓存、外部服务 | 依赖 Business、Data |
| **数据层** | `Data/` | 数据持久化、数据库访问 | 依赖 Shared |

**各层职责详解（以"创建任务"为例）**：

假设用户通过 Web 界面创建一个任务"从 A 点运送到 B 点"，整个流程如下：

```
1. Controllers/ (表现层)
   └── TasksController.Create()
       • 接收 HTTP POST 请求
       • 验证参数（路线是否存在、参数是否合法）
       • 调用 Application 层的 TaskApplicationService

2. Application/Services/ (应用服务层 - 协调层)
   └── TaskApplicationService.CreateTask()
       • 从 Data 层读取所有小车状态
       • 调用 Business 层的 DispatchService 选择合适的小车
       • 将任务保存到数据库（Data 层）
       • 通过 Infrastructure 层的 MQTT 服务发送任务给小车
       • 处理事务（如果任何一步失败，回滚）

3. Business/Services/ (业务层 - 核心逻辑)
   └── DispatchService.AssignTask()
       • 业务规则：筛选可用小车（状态=空闲，电量>20%）
       • 业务规则：计算每辆车到起点的距离
       • 业务规则：选择最近的小车
       • 业务规则：检查路线冲突
       • 返回选中的小车（纯业务逻辑，不涉及数据库、MQTT）

4. Data/ (数据层)
   └── TaskRepository.Save()
       • 将任务信息保存到 PostgreSQL 数据库
       • 更新小车状态为"执行任务中"

5. Infrastructure/Mqtt/ (基础设施层)
   └── MqttBrokerService.Publish()
       • 通过 MQTT 协议发送任务消息给选中的小车
       • 处理消息发送失败的情况
```

**为什么需要 Application 层？**

- **Business 层**：只负责"选哪辆车"这个业务决策，不关心数据怎么存、消息怎么发
- **Application 层**：负责把 Business 的决策结果"串联起来"——保存数据、发送消息、处理异常
- **好处**：如果以后不用 MQTT 了，改用 HTTP，只需要改 Infrastructure 层，Business 层完全不用动

**设计优势**：
1. **职责清晰**：业务逻辑与基础设施分离，便于维护和测试
2. **易于测试**：业务层可独立进行单元测试，不依赖数据库、MQTT 等
3. **便于扩展**：修改 MQTT 实现或替换基础设施不影响业务逻辑
4. **代码复用**：业务层可被其他项目引用（如测试项目、模拟器项目）

### 7.3 数据库设计

#### 7.3.1 核心表结构

```sql
-- 小车表
CREATE TABLE agvs (
    id VARCHAR(50) PRIMARY KEY,          -- 小车ID，如 V001
    name VARCHAR(100) NOT NULL,          -- 小车名称
    password VARCHAR(100) NOT NULL,      -- MQTT 连接密码
    status INT NOT NULL DEFAULT 0,       -- 状态
    battery INT DEFAULT 100,             -- 电量
    position_x DECIMAL(10,2),            -- X坐标
    position_y DECIMAL(10,2),            -- Y坐标
    position_angle DECIMAL(5,2),         -- 朝向
    current_station_id VARCHAR(50),      -- 当前站点
    current_task_id VARCHAR(50),         -- 当前任务
    last_online TIMESTAMP,               -- 最后在线时间
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 站点表
CREATE TABLE stations (
    id VARCHAR(50) PRIMARY KEY,          -- 站点ID
    name VARCHAR(100) NOT NULL,          -- 站点名称
    x DECIMAL(10,2) NOT NULL,            -- X坐标
    y DECIMAL(10,2) NOT NULL,            -- Y坐标
    type VARCHAR(50),                    -- 类型: pickup/dropoff/charge/standby
    description TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 路线表
CREATE TABLE routes (
    id VARCHAR(50) PRIMARY KEY,          -- 路线ID
    name VARCHAR(100) NOT NULL,          -- 路线名称
    waypoints JSONB NOT NULL,            -- 路径点 (JSON数组)
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 任务表
CREATE TABLE tasks (
    id VARCHAR(50) PRIMARY KEY,          -- 任务ID
    type INT NOT NULL,                   -- 任务类型
    status INT NOT NULL DEFAULT 0,       -- 任务状态
    priority INT DEFAULT 1,              -- 优先级 (1最高)
    assigned_agv_id VARCHAR(50),         -- 分配的小车
    route_id VARCHAR(50),                -- 路线ID
    waypoints JSONB,                     -- 路径点快照
    description TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    assigned_at TIMESTAMP,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    created_by VARCHAR(100)              -- 创建人
);

-- 历史记录表
CREATE TABLE task_logs (
    id BIGSERIAL PRIMARY KEY,
    task_id VARCHAR(50) NOT NULL,
    agv_id VARCHAR(50),
    action VARCHAR(50) NOT NULL,         -- 动作: created/assigned/started/completed/cancelled/failed
    message TEXT,
    position_x DECIMAL(10,2),
    position_y DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT NOW()
);

-- 异常记录表
CREATE TABLE exception_logs (
    id BIGSERIAL PRIMARY KEY,
    agv_id VARCHAR(50) NOT NULL,
    task_id VARCHAR(50),
    exception_type INT NOT NULL,
    severity VARCHAR(20) NOT NULL,
    message TEXT,
    position_x DECIMAL(10,2),
    position_y DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT NOW(),
    resolved_at TIMESTAMP,
    resolved_by VARCHAR(100)
);
```

---

## 八、核心功能设计

### 8.1 内嵌 MQTT Broker 服务

```csharp
/// <summary>
/// MQTT Broker 托管服务
/// 内嵌MQTT Broker，处理小车连接和消息
///
/// 注意：本服务注册为 Singleton，不能直接注入 Scoped 的 DbContext/Repository，
/// 需通过 IServiceScopeFactory 在使用时创建 scope 来获取
/// </summary>
public class MqttBrokerService : IHostedService, IMqttBrokerService, IDisposable
{
    private readonly ILogger<MqttBrokerService> _logger;
    private readonly IServiceScopeFactory _serviceScopeFactory;
    private readonly IConfiguration _configuration;
    private readonly IMqttMessageHandler _messageHandler;
    private MqttServer? _mqttServer;

    public MqttBrokerService(
        ILogger<MqttBrokerService> logger,
        IServiceScopeFactory serviceScopeFactory,
        IConfiguration configuration,
        IMqttMessageHandler messageHandler)
    {
        _logger = logger;
        _serviceScopeFactory = serviceScopeFactory;
        _configuration = configuration;
        _messageHandler = messageHandler;
    }

    public async Task StartAsync(CancellationToken cancellationToken)
    {
        var port = _configuration.GetValue<int>("Mqtt:Port");

        var options = new MqttServerOptionsBuilder()
            .WithDefaultEndpoint()
            .WithDefaultEndpointPort(port)
            .Build();

        _mqttServer = new MqttFactory().CreateMqttServer(options);

        // 客户端连接验证
        // 触发时机：当客户端（AGV小车）尝试建立连接时触发（在连接建立之前）
        _mqttServer.ValidatingConnectionAsync += async e =>
        {
            var clientId = e.ClientId;
            var username = e.UserName;
            var password = e.Password;

            // 验证客户端ID和用户名是否一致
            if (string.IsNullOrEmpty(clientId) || clientId != username)
            {
                _logger.LogError("[MQTT Broker] 客户端 {ClientId} 认证失败: ClientId和Username不一致", clientId);
                e.ReasonCode = MqttConnectReasonCode.BadUserNameOrPassword;
                return;
            }

            // 从数据库验证小车
            using var scope = _serviceScopeFactory.CreateScope();
            var agvRepository = scope.ServiceProvider.GetRequiredService<IRepository<Agv>>();

            var spec = new AgvByAgvCodeSpec(clientId);
            var agv = await agvRepository.FirstOrDefaultAsync(spec);

            if (agv == null || !agv.VerifyPassword(password))
            {
                _logger.LogError("[MQTT Broker] 客户端 {ClientId} 认证失败", clientId);
                e.ReasonCode = MqttConnectReasonCode.BadUserNameOrPassword;
                return;
            }

            e.ReasonCode = MqttConnectReasonCode.Success;
        };

        // 消息拦截处理
        // 触发时机：当有消息发布到 Broker 时（无论是客户端发布还是服务端发布）
        _mqttServer.InterceptingPublishAsync += async e =>
        {
            var topic = e.ApplicationMessage.Topic;
            var payload = Encoding.UTF8.GetString(e.ApplicationMessage.PayloadSegment);

            // 解析 Topic 获取 AgvCode 和消息类型
            var (agvCode, messageType) = MqttTopics.ParseTopic(topic);
            if (string.IsNullOrWhiteSpace(agvCode) || string.IsNullOrWhiteSpace(messageType))
            {
                _logger.LogError("[MQTT Broker] 无法解析 Topic: {Topic}", topic);
                return;
            }

            // 持久化消息到数据库（异步不阻塞消息处理）
            _ = Task.Run(async () => await SaveMessageLogAsync(
                topic, payload, e.ClientId,
                (int)e.ApplicationMessage.QualityOfServiceLevel,
                MqttMessageDirection.Inbound, agvCode, messageType
            ));

            // 根据消息类型精确匹配分发处理
            switch (messageType)
            {
                case MqttTopics.MessageTypeStatus:
                    var statusMessage = JsonSerializer.Deserialize<StatusMessage>(payload);
                    if (statusMessage != null)
                        await _messageHandler.HandleStatusAsync(agvCode, statusMessage);
                    break;

                case MqttTopics.MessageTypeTaskProgress:
                    var progressMessage = JsonSerializer.Deserialize<TaskProgressMessage>(payload);
                    if (progressMessage != null)
                        await _messageHandler.HandleTaskProgressAsync(agvCode, progressMessage);
                    break;

                case MqttTopics.MessageTypeException:
                    var exceptionMessage = JsonSerializer.Deserialize<ExceptionMessage>(payload);
                    if (exceptionMessage != null)
                        await _messageHandler.HandleExceptionAsync(agvCode, exceptionMessage);
                    break;
            }
        };

        // 客户端连接事件
        _mqttServer.ClientConnectedAsync += async e =>
        {
            _logger.LogInformation("[MQTT Broker] 客户端已连接: {ClientId}", e.ClientId);
            // 更新数据库中的小车状态为在线
            using var scope = _serviceScopeFactory.CreateScope();
            var agvRepository = scope.ServiceProvider.GetRequiredService<IRepository<Agv>>();
            var spec = new AgvByAgvCodeSpec(e.ClientId);
            var agv = await agvRepository.FirstOrDefaultAsync(spec);
            if (agv != null)
            {
                agv.AgvStatus = AgvStatus.Idle;
                agv.LastOnlineTime = DateTimeOffset.UtcNow;
                await agvRepository.UpdateAsync(agv);
            }
        };

        // 客户端断开事件
        _mqttServer.ClientDisconnectedAsync += async e =>
        {
            _logger.LogInformation("[MQTT Broker] 客户端已断开: {ClientId}", e.ClientId);
            // 更新数据库中的小车状态为离线
            using var scope = _serviceScopeFactory.CreateScope();
            var agvRepository = scope.ServiceProvider.GetRequiredService<IRepository<Agv>>();
            var spec = new AgvByAgvCodeSpec(e.ClientId);
            var agv = await agvRepository.FirstOrDefaultAsync(spec);
            if (agv != null)
            {
                agv.AgvStatus = AgvStatus.Offline;
                agv.LastOnlineTime = DateTimeOffset.UtcNow;
                await agvRepository.UpdateAsync(agv);
            }
        };

        await _mqttServer.StartAsync();
        _logger.LogInformation("[MQTT Broker] 启动成功，端口: {Port}", port);
    }

    // IMqttBrokerService 接口实现
    public async Task PublishTaskAssignAsync(string agvCode, TaskAssignMessage message)
    {
        var topic = MqttTopics.TaskAssign(agvCode);
        var payload = JsonSerializer.Serialize(message);
        await PublishAsync(topic, payload, MqttQualityOfServiceLevel.AtLeastOnce);
    }

    public async Task PublishTaskCancelAsync(string agvCode, TaskCancelMessage message)
    {
        var topic = MqttTopics.TaskCancel(agvCode);
        var payload = JsonSerializer.Serialize(message);
        await PublishAsync(topic, payload, MqttQualityOfServiceLevel.AtLeastOnce);
    }

    public async Task PublishCommandAsync(string agvCode, CommandMessage message)
    {
        var topic = MqttTopics.Command(agvCode);
        var payload = JsonSerializer.Serialize(message);
        await PublishAsync(topic, payload, MqttQualityOfServiceLevel.AtLeastOnce);
    }

    private async Task PublishAsync(string topic, string payload, MqttQualityOfServiceLevel qos)
    {
        if (_mqttServer == null) return;

        var message = new MqttApplicationMessageBuilder()
            .WithTopic(topic)
            .WithPayload(payload)
            .WithQualityOfServiceLevel(qos)
            .WithRetainFlag(false)
            .Build();

        await _mqttServer.InjectApplicationMessage(
            new InjectedMqttApplicationMessage(message)
            {
                SenderClientId = "Server"
            });

        // 持久化出站消息到数据库（异步不阻塞）
        var (agvCode, messageType) = MqttTopics.ParseTopic(topic);
        _ = Task.Run(async () => await SaveMessageLogAsync(
            topic, payload, "Server", (int)qos,
            MqttMessageDirection.Outbound, agvCode, messageType
        ));
    }

    private async Task SaveMessageLogAsync(string topic, string payload, string? clientId,
        int qos, MqttMessageDirection direction, string? agvCode, string? messageType)
    {
        using var scope = _serviceScopeFactory.CreateScope();
        var logRepository = scope.ServiceProvider.GetRequiredService<IRepository<MqttMessageLog>>();

        var log = new MqttMessageLog
        {
            Timestamp = DateTimeOffset.UtcNow,
            Topic = topic,
            Payload = payload,
            ClientId = clientId,
            Qos = qos,
            Direction = direction,
            AgvCode = agvCode,
            MessageType = messageType
        };

        log.OnCreate();
        await logRepository.AddAsync(log);
    }

    public async Task StopAsync(CancellationToken cancellationToken)
    {
        if (_mqttServer != null)
        {
            await _mqttServer.StopAsync();
        }
    }

    public void Dispose()
    {
        _mqttServer?.Dispose();
    }
}
```

**关键设计要点：**
1. **Singleton服务与Scoped依赖**：MqttBrokerService注册为Singleton，但需要访问Scoped的Repository，因此使用IServiceScopeFactory创建临时作用域
2. **消息拦截机制**：内嵌Broker通过InterceptingPublishAsync事件拦截所有消息，无需显式订阅Topic
3. **精确消息类型匹配**：使用MqttTopics.ParseTopic解析Topic，然后通过switch精确匹配消息类型，避免使用Contains模糊匹配
4. **连接认证**：验证ClientId必须等于Username，且都是小车编码（如V001）
5. **消息持久化**：所有入站和出站消息都异步持久化到数据库，不阻塞消息处理流程
6. **在线状态管理**：客户端连接/断开时自动更新数据库中的小车状态和最后在线时间

### 8.2 调度引擎

```
┌─────────────────────────────────────────────────────────┐
│                      调度引擎                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  输入:                                                  │
│    • 待分配任务队列                                      │
│    • 所有小车当前状态（来自 MQTT 状态上报）              │
│    • 可用路线配置                                        │
│                                                         │
│  调度策略:                                               │
│    1. 筛选可用小车 (状态=Idle, 电量>20%)                 │
│    2. 计算每辆车到任务起点的距离                         │
│    3. 选择最近的空闲小车                                 │
│    4. 检查路线冲突 (是否与其他小车路线交叉)              │
│    5. 通过 MQTT 发布任务到 agv/{id}/task/assign         │
│                                                         │
│  输出:                                                  │
│    • 任务分配结果                                        │
│    • MQTT 消息发布                                       │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 8.3 功能模块划分

| 模块 | 功能 | 界面入口 |
|------|------|----------|
| 监控大屏 | 实时显示所有小车位置、状态 | Web首页 |
| 任务管理 | 创建任务、查看任务列表、取消任务 | Web+APP |
| 小车管理 | 查看小车详情、手动控制(暂停/继续) | Web+APP |
| 路线配置 | 配置站点、路线 | Web |
| 历史查询 | 查询任务历史、异常记录 | Web |
| 系统设置 | 参数配置 | Web |

### 8.4 Web 端页面设计

```
┌─────────────────────────────────────────────────────────────┐
│  Web 端 (Blazor Server)                                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  📊 监控模块                                                │
│  └── 监控大屏        地图显示小车位置、状态、电量、任务      │
│                                                             │
│  📋 任务模块                                                │
│  ├── 任务列表        进行中/待分配/已完成，支持筛选          │
│  └── 创建任务        选择路线、设置优先级、下发任务          │
│                                                             │
│  🚗 小车模块                                                │
│  ├── 小车列表        所有小车状态卡片                        │
│  └── 小车详情        详细信息 + 控制按钮（暂停/继续/急停）   │
│                                                             │
│  ⚙️ 配置模块                                                │
│  ├── 站点管理        增删改站点，地图标注                    │
│  └── 路线管理        增删改路线，路径编辑                    │
│                                                             │
│  📜 历史模块                                                │
│  ├── 任务历史        按时间/小车/状态筛选                    │
│  └── 异常记录        异常日志列表                            │
│                                                             │
│  🔧 系统模块                                                │
│  └── 系统设置        参数配置                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 8.5 安卓端页面设计

```
┌─────────────────────────────────────────────────────────────┐
│  安卓端 (Avalonia)                                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  🏠 首页                                                    │
│  └── 状态概览        小车状态卡片、进行中任务数、快捷入口    │
│                                                             │
│  📋 任务模块                                                │
│  ├── 任务列表        进行中/已完成任务                       │
│  └── 创建任务        快速选择路线、下发任务                  │
│                                                             │
│  🚗 小车模块                                                │
│  └── 小车列表        状态卡片 + 快捷控制按钮                 │
│                                                             │
│  🔔 通知模块                                                │
│  └── 消息中心        异常告警推送、任务完成通知              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 8.6 功能对比

| 功能 | Web | APP | 说明 |
|------|:---:|:---:|------|
| 监控大屏（地图） | ✅ | ❌ | 手机屏幕小，不适合地图 |
| 任务列表 | ✅ | ✅ | APP 精简版 |
| 创建任务 | ✅ | ✅ | APP 快速创建 |
| 小车控制 | ✅ | ✅ | 暂停/继续/急停 |
| 站点/路线配置 | ✅ | ❌ | 配置类操作在 Web 完成 |
| 历史查询 | ✅ | ❌ | 查询类操作在 Web 完成 |
| 异常通知 | ✅ | ✅ | APP 支持推送 |
| 系统设置 | ✅ | ❌ | 管理类操作在 Web 完成 |

**设计原则**：Web 功能完整，APP 只做移动场景高频操作（看状态、发任务、紧急控制）。

---

## 九、部署架构

### 9.1 服务器部署

```
阿里云ECS (推荐配置: 2核4G)
├── Docker
│   ├── agv-dispatch          # 调度服务 (内嵌 MQTT Broker + REST API + Blazor)
│   └── postgres              # 数据库
│
└── Nginx (反向代理 + HTTPS)
```

**说明**：MQTT Broker 使用 MQTTnet 内嵌到调度服务中，无需独立部署。

### 9.2 网络配置

| 端口 | 用途 |
|------|------|
| 443 | HTTPS (Web界面 + REST API) |
| 1883 | MQTT TCP (小车连接) |
| 8883 | MQTT TLS (可选，加密连接) |
| 5000 | 内部服务端口 |
| 5432 | PostgreSQL (仅内网) |

### 9.3 域名规划

```
调度系统:     haining-agv.drinduan.com
API地址:      haining-agv.drinduan.com/api
MQTT Broker:  haining-agv.drinduan.com:8883 (TLS)
```

### 9.4 TLS 证书配置

使用 Let's Encrypt 免费证书为 MQTT 通信加密。

#### 9.4.1 为什么需要 TLS

| 风险 | 不用 TLS | 用 TLS |
|------|----------|--------|
| 数据被窃听 | 明文传输，可被截获 | 加密传输 |
| 密码泄露 | MQTT密码明文传输 | 加密保护 |
| 指令被篡改 | 可伪造控制指令 | 无法篡改 |

**建议**：开发阶段可用 1883 明文，生产环境使用 8883 TLS。

#### 9.4.2 证书申请步骤

**1. 域名解析**

在域名服务商处添加 A 记录：
```
haining-agv.drinduan.com → 阿里云服务器IP
```

**2. 安装 Certbot**

```bash
# Ubuntu/Debian
apt update && apt install certbot

# CentOS
yum install certbot
```

**3. 申请证书**

```bash
# 申请前先停掉占用 80 端口的服务（如 Nginx）
systemctl stop nginx

# 申请证书
certbot certonly --standalone -d haining-agv.drinduan.com

# 申请成功后启动 Nginx
systemctl start nginx
```

**4. 证书文件位置**

```
证书: /etc/letsencrypt/live/haining-agv.drinduan.com/fullchain.pem
私钥: /etc/letsencrypt/live/haining-agv.drinduan.com/privkey.pem
```

#### 9.4.3 内嵌 MQTT Broker 配置 TLS

在 ASP.NET Core 服务中配置 MQTTnet 的 TLS：

```csharp
// Program.cs
var certificate = new X509Certificate2(
    "/etc/letsencrypt/live/haining-agv.drinduan.com/fullchain.pem",
    "/etc/letsencrypt/live/haining-agv.drinduan.com/privkey.pem"
);

var mqttServerOptions = new MqttServerOptionsBuilder()
    .WithDefaultEndpoint()           // 1883 明文端口（可选，开发用）
    .WithEncryptedEndpoint()         // 8883 TLS 端口
    .WithEncryptedEndpointPort(8883)
    .WithEncryptionCertificate(certificate)
    .Build();

var mqttServer = new MqttFactory().CreateMqttServer(mqttServerOptions);
await mqttServer.StartAsync();
```

Docker 部署时挂载证书：

```yaml
# docker-compose.yml
services:
  agv-dispatch:
    image: agv-dispatch:latest
    ports:
      - "443:443"    # HTTPS
      - "1883:1883"  # MQTT (开发)
      - "8883:8883"  # MQTT TLS (生产)
    volumes:
      - /etc/letsencrypt:/etc/letsencrypt:ro
```

#### 9.4.4 小车端连接配置 (Python)

```python
import ssl
import paho.mqtt.client as mqtt

client = mqtt.Client(client_id="V001", clean_session=False)
client.username_pw_set("V001", "your-password")

# 启用 TLS
client.tls_set(
    ca_certs=None,  # 使用系统CA证书（Let's Encrypt被信任）
    cert_reqs=ssl.CERT_REQUIRED,
    tls_version=ssl.PROTOCOL_TLS
)

# 连接到 8883 端口
client.connect("haining-agv.drinduan.com", 8883, keepalive=60)
```

#### 9.4.5 证书自动续期

Let's Encrypt 证书有效期 90 天，Certbot 会自动续期：

```bash
# 测试续期是否正常
certbot renew --dry-run

# 查看定时任务（已自动添加）
systemctl list-timers | grep certbot
```

**注意**：续期后需要重启服务加载新证书：

```bash
# 创建续期后自动重启的钩子
cat > /etc/letsencrypt/renewal-hooks/post/restart-agv.sh << 'EOF'
#!/bin/bash
docker restart agv-dispatch
EOF
chmod +x /etc/letsencrypt/renewal-hooks/post/restart-agv.sh
```

---

## 十、开发计划

### 10.1 里程碑

| 阶段 | 内容 | 交付物 |
|------|------|--------|
| M1 | 基础框架搭建 | 项目骨架、数据库、基础API |
| M2 | MQTT 集成 | 内嵌Broker、消息处理、模拟器 |
| M3 | 调度核心 | 任务分配、状态管理 |
| M4 | Web界面 | 监控大屏、任务管理 |
| M5 | 安卓APP | 基础功能 |
| M6 | 联调测试 | 与硬件团队对接 |
| M7 | 部署上线 | 生产环境部署 |

### 10.2 优先级

1. **P0 (必须)**: MQTT通信、任务下发、状态上报、基础监控
2. **P1 (重要)**: 调度算法、历史记录、异常处理
3. **P2 (一般)**: 高级监控、报表统计、参数配置

---

## 十一、附录

### 11.1 错误码定义

| 错误码 | 说明 |
|--------|------|
| E001 | 小车离线 |
| E002 | 小车忙碌 |
| E003 | 任务不存在 |
| E004 | 路线不存在 |
| E005 | 电量不足 |
| E006 | 认证失败 |

### 11.2 硬件团队对接示例 (Python)

```python
import json
import time
from datetime import datetime
import paho.mqtt.client as mqtt

class AgvClient:
    def __init__(self, broker_host, agv_code, password):
        self.broker_host = broker_host
        self.agv_code = agv_code
        self.password = password
        self.client = mqtt.Client(client_id=agv_code, clean_session=False)

        # 设置认证（ClientId和Username必须一致）
        self.client.username_pw_set(agv_code, password)

        # 设置回调
        self.client.on_connect = self._on_connect
        self.client.on_message = self._on_message
        self.client.on_disconnect = self._on_disconnect

    def _on_connect(self, client, userdata, flags, rc):
        print(f"已连接到 Broker, rc={rc}")
        # 订阅任务和指令
        client.subscribe(f"agv/{self.agv_code}/task/assign", qos=1)
        client.subscribe(f"agv/{self.agv_code}/task/cancel", qos=1)
        client.subscribe(f"agv/{self.agv_code}/command", qos=1)

    def _on_message(self, client, userdata, msg):
        payload = json.loads(msg.payload.decode())
        topic = msg.topic

        if "task/assign" in topic:
            self._handle_task_assign(payload)
        elif "task/cancel" in topic:
            self._handle_task_cancel(payload)
        elif "command" in topic:
            self._handle_command(payload)

    def _on_disconnect(self, client, userdata, rc):
        print(f"连接断开, rc={rc}, 尝试重连...")

    def _handle_task_assign(self, payload):
        print(f"收到任务: {payload['taskId']}")
        print(f"  类型: {payload['taskType']}")
        print(f"  起点: {payload['startStationCode']}")
        print(f"  终点: {payload['endStationCode']}")

        # 应答任务已接收
        self._publish_progress(
            payload['taskId'],
            status=10,  # Assigned
            progress=0,
            message="任务已接收"
        )

        # TODO: 实际执行任务

    def _handle_task_cancel(self, payload):
        print(f"任务取消: {payload['taskId']}, 原因: {payload.get('reason', '未指定')}")

        # 应答任务已取消
        self._publish_progress(
            payload['taskId'],
            status=40,  # Cancelled
            progress=None,
            message="任务已取消"
        )

    def _handle_command(self, payload):
        command_type = payload['commandType']
        print(f"收到指令: commandId={payload['commandId']}, type={command_type}")

        if command_type == 30:  # Pause
            print("暂停执行")
            # TODO: 暂停小车运动
        elif command_type == 31:  # Resume
            print("继续执行")
            # TODO: 恢复小车运动

    def _publish_progress(self, task_id, status, progress, message):
        """上报任务进度"""
        payload = {
            "agvCode": self.agv_code,
            "taskId": task_id,
            "timestamp": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ"),
            "status": status,
            "progressPercentage": progress,
            "message": message
        }
        self.client.publish(
            f"agv/{self.agv_code}/task/progress",
            json.dumps(payload),
            qos=1
        )

    def publish_status(self, status, battery, position, current_task_id=None, error_code=None, message=None):
        """上报状态"""
        payload = {
            "agvCode": self.agv_code,
            "timestamp": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ"),
            "status": status,
            "battery": battery,
            "speed": 0.0,
            "position": position,
            "currentTaskId": current_task_id,
            "errorCode": error_code,
            "message": message
        }
        # 状态消息建议使用 QoS=0 以减少网络开销
        self.client.publish(
            f"agv/{self.agv_code}/status",
            json.dumps(payload),
            qos=0
        )

    def publish_exception(self, exception_type, severity, message, position=None, task_id=None):
        """上报异常"""
        payload = {
            "agvCode": self.agv_code,
            "timestamp": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ"),
            "exceptionType": exception_type,
            "severity": severity,
            "message": message,
            "position": position,
            "taskId": task_id
        }
        self.client.publish(
            f"agv/{self.agv_code}/exception",
            json.dumps(payload),
            qos=1
        )

    def connect(self):
        """连接 Broker"""
        self.client.connect(self.broker_host, 1883, keepalive=60)

    def run(self):
        """主循环"""
        self.connect()
        self.client.loop_start()

        # 定时上报状态（每5秒）
        while True:
            self.publish_status(
                status=10,  # Idle
                battery=85,
                position={"x": 100.0, "y": 200.0, "angle": 90.0, "stationId": None}
            )
            time.sleep(5)


# 使用示例
if __name__ == "__main__":
    client = AgvClient(
        broker_host="localhost",
        agv_code="V001",
        password="your-password-here"
    )
    try:
        client.run()
    except KeyboardInterrupt:
        print("退出")
```

**枚举值参考：**

```python
# 小车状态
class AgvStatus:
    OFFLINE = 0
    IDLE = 10
    RUNNING = 20
    CHARGING = 30
    ERROR = 90

# 任务状态
class TaskStatus:
    PENDING = 0
    ASSIGNED = 10
    EXECUTING = 20
    COMPLETED = 30
    CANCELLED = 40
    FAILED = 50

# 任务类型
class TaskType:
    TRANSPORT = 10
    CHARGE = 20
    RETURN = 30

# 控制指令类型
class CommandType:
    PAUSE = 30
    RESUME = 31

# 异常类型
class AgvExceptionType:
    OBSTACLE_DETECTED = 10
    LOW_BATTERY = 20
    NETWORK_ERROR = 30
    GPS_ERROR = 31
    EMERGENCY_STOP = 40
    OTHER = 80

# 异常严重级别
class AgvExceptionSeverity:
    INFO = 10
    WARNING = 20
    ERROR = 30
    CRITICAL = 40
```

### 11.3 参考资料

- [MQTT 协议规范](https://mqtt.org/mqtt-specification/)
- [MQTTnet 文档](https://github.com/dotnet/MQTTnet)
- [paho-mqtt Python 库](https://pypi.org/project/paho-mqtt/)
- [Avalonia UI 文档](https://docs.avaloniaui.net/)
- [Blazor 文档](https://docs.microsoft.com/aspnet/core/blazor)

---

## 修订记录

| 版本 | 日期 | 修订人 | 说明 |
|------|------|--------|------|
| v1.0 | 2026-01-04 | - | 初稿 |
| v1.1 | 2026-01-04 | - | 通信协议从SignalR改为原生WebSocket |
| v1.2 | 2026-01-04 | - | 通信协议从WebSocket改为MQTT |
| v1.3 | 2026-01-04 | - | 明确通信分工：小车用MQTT，Web/APP用HTTP轮询；补充HTTP API设计 |
| v1.4 | 2026-01-04 | - | MQTT Broker 改为内嵌方案（MQTTnet），简化部署架构；移除遗嘱消息机制 |
| v1.5 | 2026-01-04 | - | 移动端框架从 .NET MAUI 改为 Avalonia UI |
| v1.6 | 2026-01-17 | - | **依据实际代码优化MQTT协议文档**：①更新枚举值为实际值（AgvStatus、TaskStatus等）；②任务下发消息改为起点/终点模式（移除waypoints）；③移除command/ack topic；④增加message字段到StatusMessage；⑤更新MqttBrokerService实现细节；⑥字段名统一使用agvCode；⑦补充连接认证要求；⑧更新Python示例代码 |
| v1.7 | 2026-01-17 | - | **新增路径锁定机制**：①新增3个Topic（path/lock-request、path/lock-response、path/unlock）；②新增3个消息格式定义（5.2.7路段锁定请求、5.2.8路段锁定响应、5.2.9路段解锁通知）；③更新Topic订阅关系和QoS对照表 |

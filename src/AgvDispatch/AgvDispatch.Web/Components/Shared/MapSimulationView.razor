@using AgvDispatch.Shared.DTOs.MapEdges
@using AgvDispatch.Shared.DTOs.MapNodes
@using AgvDispatch.Shared.DTOs.Maps
@using AgvDispatch.Shared.DTOs.Stations
@using AgvDispatch.Shared.DTOs.Agvs
@using AgvDispatch.Shared.DTOs.Tasks
@using AgvDispatch.Shared.Enums
@using AgvDispatch.Shared.Rendering
@using AgvDispatch.Shared.PathFinding
@using AgvDispatch.Shared.Simulation
@using System.Timers
@implements IDisposable

@* åœ°å›¾ç”»å¸ƒå†…å®¹ *@
<div style="width: 100%; height: 100%; cursor: @(_isDragging ? "grabbing" : "grab");"
     @onwheel="OnWheel"
     @onwheel:preventDefault="true"
     @onmousedown="OnMouseDown"
     @onmousemove="OnMouseMove"
     @onmouseup="OnMouseUp"
     @onmouseleave="OnMouseLeave">

    @if (Map != null)
    {
        @* åœ°å›¾å±‚ *@
        <div class="map-layer">
            @((MarkupString)_mapSvg)
        </div>

        @* ä»»åŠ¡è·¯å¾„å±‚ *@
        <div class="task-paths-layer">
            @((MarkupString)_taskPathsSvg)
        </div>

        @* AGVå±‚ *@
        <div class="agv-layer">
            @((MarkupString)_agvSvg)
        </div>

        @* ç”»å¸ƒå·¥å…·æ¡ *@
        <div class="canvas-tools">
            <MudIconButton Icon="@Icons.Material.Filled.ZoomOut"
                           Size="Size.Small"
                           OnClick="ZoomOut"
                           Title="ç¼©å°" />
            <MudNumericField T="int"
                             Value="@((int)(_scale * 100))"
                             ValueChanged="OnZoomValueChanged"
                             Min="1"
                             Max="100"
                             Variant="Variant.Outlined"
                             HideSpinButtons="true"
                             Adornment="Adornment.End"
                             AdornmentText="%"
                             Style="width: 70px;"
                             Margin="Margin.Dense" />
            <MudIconButton Icon="@Icons.Material.Filled.ZoomIn"
                           Size="Size.Small"
                           OnClick="ZoomIn"
                           Title="æ”¾å¤§" />
            <MudIconButton Icon="@Icons.Material.Filled.FitScreen"
                           Size="Size.Small"
                           OnClick="FitToScreen"
                           Title="é€‚åº”ç”»å¸ƒ" />
            <MudDivider Vertical="true" FlexItem="true" Class="mx-2" />
            <MudText Typo="Typo.caption" Class="mr-1">å…ƒç´ :</MudText>
            <MudIconButton Icon="@Icons.Material.Filled.RemoveCircleOutline"
                           Size="Size.Small"
                           OnClick="DecreaseElementScale"
                           Title="å‡å°å…ƒç´ " />
            <MudText Typo="Typo.caption">@(_elementScale.ToString("F1"))x</MudText>
            <MudIconButton Icon="@Icons.Material.Filled.AddCircleOutline"
                           Size="Size.Small"
                           OnClick="IncreaseElementScale"
                           Title="å¢å¤§å…ƒç´ " />
        </div>

        @* ç¼©ç•¥å›¾ *@
        <div class="minimap-container"
             @onclick="OnMinimapClick">
            <div class="minimap-content">
                @((MarkupString)_minimapMapSvg)
                @((MarkupString)_minimapAgvSvg)
                @((MarkupString)_minimapOverlaySvg)
            </div>
        </div>
    }
</div>

@code {
    // ===== å‚æ•°å®šä¹‰ =====

    /// <summary>
    /// åœ°å›¾æ•°æ®
    /// </summary>
    [Parameter] public MapDetailDto? Map { get; set; }

    /// <summary>
    /// åœ°å›¾èŠ‚ç‚¹åˆ—è¡¨
    /// </summary>
    [Parameter] public List<MapNodeListItemDto> Nodes { get; set; } = [];

    /// <summary>
    /// åœ°å›¾è¾¹åˆ—è¡¨
    /// </summary>
    [Parameter] public List<MapEdgeListItemDto> Edges { get; set; } = [];

    /// <summary>
    /// ç«™ç‚¹åˆ—è¡¨
    /// </summary>
    [Parameter] public List<StationListItemDto> Stations { get; set; } = [];

    /// <summary>
    /// AGVåˆ—è¡¨
    /// </summary>
    [Parameter] public List<AgvListItemDto> Agvs { get; set; } = [];

    /// <summary>
    /// ä»»åŠ¡åˆ—è¡¨
    /// </summary>
    [Parameter] public List<TaskListItemDto> Tasks { get; set; } = [];

    /// <summary>
    /// æ¸²æŸ“é€‰é¡¹
    /// </summary>
    [Parameter] public MapRenderOptions RenderOptions { get; set; } = new();

    /// <summary>
    /// æ˜¯å¦å¯ç”¨è‡ªåŠ¨æ¨¡æ‹Ÿ
    /// </summary>
    [Parameter] public bool EnableAutoSimulation { get; set; } = true;

    /// <summary>
    /// æ¨¡æ‹Ÿé€Ÿåº¦æ¯”ä¾‹ï¼ˆ0-100ï¼‰
    /// </summary>
    [Parameter] public int SimulationSpeedRatio { get; set; } = 80;

    /// <summary>
    /// è¿½è¸ªæ¨¡å¼ï¼ˆ"none" æˆ– ä»»åŠ¡IDï¼‰
    /// </summary>
    [Parameter] public string TrackingMode { get; set; } = "none";

    /// <summary>
    /// è¿½è¸ªæ¨¡å¼å˜åŒ–äº‹ä»¶å›è°ƒ
    /// </summary>
    [Parameter] public EventCallback<string> TrackingModeChanged { get; set; }

    // ===== å†…éƒ¨çŠ¶æ€ =====

    // æ¸²æŸ“å™¨
    private MapRenderer _mapRenderer = new();
    private MiniMapRenderer _minimapRenderer = new();
    private SimulationRenderer _simulationRenderer = new();
    private MapRenderData _renderData = new();

    // SVGå­—ç¬¦ä¸²
    private string _mapSvg = string.Empty;
    private string _agvSvg = string.Empty;
    private string _taskPathsSvg = string.Empty;
    private string _minimapMapSvg = string.Empty;
    private string _minimapAgvSvg = string.Empty;
    private string _minimapOverlaySvg = string.Empty;

    // ä»»åŠ¡æ¨¡æ‹Ÿ
    private Dictionary<Guid, PathfindingResult> _taskPathCache = new();
    private Dictionary<Guid, AgvSimulator> _taskSimulators = new();
    private Dictionary<Guid, decimal> _lastTaskProgress = new();
    private System.Timers.Timer? _simulationTimer;

    // è§†å›¾æ§åˆ¶
    private float _viewWidth = 1200f;
    private float _viewHeight = 800f;
    private float _scale = 0.2f;
    private float _elementScale = 1.0f;
    private float _offsetX = 50f;
    private float _offsetY = 50f;
    private bool _isDragging = false;
    private double _lastMouseX;
    private double _lastMouseY;

    // ç¼©ç•¥å›¾
    private const float MinimapWidth = 330f;
    private const float MinimapHeight = 440f;
    private float _minimapScale = 0.01f;
    private float _minimapOffsetX = 0f;
    private float _minimapOffsetY = 0f;

    private bool _initialized = false;

    // ===== ç”Ÿå‘½å‘¨æœŸæ–¹æ³• =====

    protected override void OnInitialized()
    {
        // å¯åŠ¨æ¨¡æ‹Ÿå®šæ—¶å™¨
        _simulationTimer = new System.Timers.Timer(50);
        _simulationTimer.Elapsed += OnSimulationTimerElapsed;
        if (EnableAutoSimulation)
        {
            _simulationTimer.Start();
        }
    }

    protected override void OnParametersSet()
    {
        Console.WriteLine($"[MapSimulationView] OnParametersSet - Initialized: {_initialized}, TrackingMode: {TrackingMode}, Tasks: {Tasks.Count}");

        if (!_initialized && Map != null && Nodes.Count > 0)
        {
            _initialized = true;
            InitializeRenderData();
            RenderAll();
            Console.WriteLine("[MapSimulationView] é¦–æ¬¡åˆå§‹åŒ–å®Œæˆ");
        }
        else if (_initialized)
        {
            Console.WriteLine("[MapSimulationView] å‚æ•°æ›´æ–°ï¼Œå¼€å§‹é‡æ–°æ¸²æŸ“");

            // 1. å¤„ç†æ‰§è¡Œä¸­çš„ä»»åŠ¡ï¼ˆæ›´æ–°æ¨¡æ‹Ÿå™¨çŠ¶æ€ï¼Œæ¸²æŸ“ä»»åŠ¡è·¯å¾„å’Œå°åœ°å›¾ï¼‰
            ProcessExecutingTasks();

            // 2. æ£€æŸ¥æ˜¯å¦éœ€è¦åº”ç”¨è¿½è¸ª
            if (TrackingMode != "none" && Guid.TryParse(TrackingMode, out var trackedTaskId))
            {
                // è¿½è¸ªæ¨¡å¼ï¼šApplyTracking ä¼šè°ƒç”¨ RenderMap()ï¼Œè¿›è€Œæ¸²æŸ“æ‰€æœ‰å†…å®¹
                Console.WriteLine($"[MapSimulationView] åº”ç”¨è¿½è¸ªæ¨¡å¼: {trackedTaskId}");
                ApplyTracking(trackedTaskId);
            }
            else
            {
                // éè¿½è¸ªæ¨¡å¼ï¼šåªéœ€è¦æ›´æ–° AGV å±‚ï¼ˆåŒ…æ‹¬ç©ºé—² AGVï¼‰å’Œå°åœ°å›¾
                Console.WriteLine("[MapSimulationView] éè¿½è¸ªæ¨¡å¼ï¼Œæ›´æ–° AGV å’Œå°åœ°å›¾");
                RenderAgvs();  // ä¼šè‡ªåŠ¨è°ƒç”¨ RenderMinimapAgvs()ï¼ˆç¬¬ 657 è¡Œï¼‰
            }
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            // é¦–æ¬¡æ¸²æŸ“åçš„åˆå§‹åŒ–ï¼ˆå¦‚æœéœ€è¦ï¼‰
        }
    }

    public void Dispose()
    {
        _simulationTimer?.Dispose();

        // æ¸…ç†æ‰€æœ‰æ¨¡æ‹Ÿå™¨
        foreach (var simulator in _taskSimulators.Values)
        {
            simulator.Stop();
        }
        _taskSimulators.Clear();
        _taskPathCache.Clear();
    }

    // ===== åˆå§‹åŒ–æ–¹æ³• =====

    private void InitializeRenderData()
    {
        if (Map == null) return;

        _renderData.Width = Map.Width;
        _renderData.Height = Map.Height;
        _renderData.Nodes = Nodes;
        _renderData.Edges = Edges;
        _renderData.Stations = Stations;

        // è®¾ç½®ç¼©æ”¾æ¯”ä¾‹
        _scale = 0.2f;

        // è®¡ç®—åç§»ä½¿åœ°å›¾å±…ä¸­
        var mapWidth = (float)Map.Width;
        var mapHeight = (float)Map.Height;
        _offsetX = (_viewWidth - mapWidth * _scale) / 2f;
        _offsetY = (_viewHeight - mapHeight * _scale) / 2f;
    }

    private void RenderAll()
    {
        RenderMap();
    }

    // ===== ä»»åŠ¡æ¨¡æ‹Ÿæ–¹æ³• =====

    /// <summary>
    /// å¤„ç†æ‰§è¡Œä¸­çš„ä»»åŠ¡
    /// </summary>
    private void ProcessExecutingTasks()
    {
        var executingTasks = Tasks.Where(t => t.TaskStatus == TaskJobStatus.Executing).ToList();

        // æ¸…ç†å·²å®Œæˆæˆ–å–æ¶ˆçš„ä»»åŠ¡
        var taskIdsToRemove = _taskSimulators.Keys
            .Where(id => !executingTasks.Any(t => t.Id == id))
            .ToList();

        foreach (var taskId in taskIdsToRemove)
        {
            if (_taskSimulators.TryGetValue(taskId, out var simulator))
            {
                simulator.Stop();
            }
            _taskSimulators.Remove(taskId);
            _taskPathCache.Remove(taskId);
            _lastTaskProgress.Remove(taskId);

            // å¦‚æœæ­£åœ¨è¿½è¸ªçš„ä»»åŠ¡å·²å®Œæˆï¼Œå–æ¶ˆè¿½è¸ª
            if (TrackingMode == taskId.ToString())
            {
                _ = TrackingModeChanged.InvokeAsync("none");
            }
        }

        // å¤„ç†æ¯ä¸ªæ‰§è¡Œä¸­çš„ä»»åŠ¡
        foreach (var task in executingTasks)
        {
            OnTaskProgressUpdated(task);
        }

        // æ¸²æŸ“ä»»åŠ¡è·¯å¾„å’Œå°åœ°å›¾
        RenderTaskPaths();
        RenderMinimapAgvs();
    }

    /// <summary>
    /// ä»»åŠ¡è¿›åº¦æ›´æ–°å¤„ç†
    /// </summary>
    private void OnTaskProgressUpdated(TaskListItemDto task)
    {
        // å¦‚æœè¿›åº¦ä¸º nullï¼Œåˆå§‹åŒ–ä¸º 0ï¼Œä»¥ä¾¿å¯åŠ¨è‡ªåŠ¨æ¨¡æ‹Ÿ
        var progress = task.ProgressPercentage ?? 0m;

        if (progress < 0)
            return;

        // æ£€æŸ¥è¿›åº¦æ˜¯å¦å˜åŒ–
        var progressChanged = !_lastTaskProgress.ContainsKey(task.Id) ||
                              _lastTaskProgress[task.Id] != progress;

        if (!progressChanged && _taskSimulators.ContainsKey(task.Id))
            return; // è¿›åº¦æœªå˜åŒ–ä¸”æ¨¡æ‹Ÿå™¨å·²å­˜åœ¨ï¼Œæ— éœ€å¤„ç†

        _lastTaskProgress[task.Id] = progress;

        // è·å–æˆ–åˆ›å»ºè·¯å¾„
        if (!_taskPathCache.ContainsKey(task.Id))
        {
            var path = CalculateTaskPath(task);
            if (path == null || !path.Success)
                return;

            _taskPathCache[task.Id] = path;
        }

        var pathResult = _taskPathCache[task.Id];

        // åˆ›å»ºæ–°å®ä¾‹
        if (!_taskSimulators.ContainsKey(task.Id))
        {
            var simulator = CreateTaskSimulator(pathResult, task);
            if (simulator == null)
                return;

            _taskSimulators[task.Id] = simulator;

            // ğŸ†• ä¼˜å…ˆæ£€æŸ¥ç«™ç‚¹ä½ç½®
            var agv = Agvs.FirstOrDefault(a => a.AgvCode == task.AssignedAgvCode);
            if (agv != null && !string.IsNullOrEmpty(agv.CurrentStationCode))
            {
                if (TryJumpToStationInPath(task.Id, simulator, agv.CurrentStationCode, out bool stationInPath) && stationInPath)
                {
                    // ç«™ç‚¹åœ¨è·¯å¾„ä¸Šï¼Œç›´æ¥å®šä½åˆ°ç«™ç‚¹å¹¶æš‚åœ
                    simulator.Pause();
                    return; // ä¸å¯åŠ¨è‡ªåŠ¨æ¨¡æ‹Ÿ
                }
            }

            // ç«™ç‚¹ä¸åœ¨è·¯å¾„ä¸Šæˆ–ä¸ºç©ºï¼Œä½¿ç”¨è¿›åº¦ç™¾åˆ†æ¯”
            simulator.JumpToProgress(progress);

            // å¯åŠ¨æ¨¡æ‹Ÿ
            if (EnableAutoSimulation &&
                simulator.State != SimulationState.Running &&
                simulator.State != SimulationState.Completed)
            {
                simulator.Start();
            }
        }
        // å¤ç”¨å·²æœ‰å®ä¾‹
        else
        {
            // æ›´æ–°ç°æœ‰æ¨¡æ‹Ÿå™¨çš„è¿›åº¦
            var taskSimulator = _taskSimulators[task.Id];
            var agv = Agvs.FirstOrDefault(a => a.AgvCode == task.AssignedAgvCode);

            if (agv != null && !string.IsNullOrEmpty(agv.CurrentStationCode))
            {
                // æœ‰ç«™ç‚¹ï¼šè·³è½¬åˆ°ç«™ç‚¹ä½ç½®
                if (TryJumpToStationInPath(task.Id, taskSimulator, agv.CurrentStationCode, out bool stationInPath) && stationInPath)
                {
                    taskSimulator.Pause();
                    return;
                }
            }

            // æ— ç«™ç‚¹æˆ–ç«™ç‚¹ä¸åœ¨è·¯å¾„ä¸Šï¼šä½¿ç”¨è¿›åº¦ç™¾åˆ†æ¯”
            taskSimulator.JumpToProgress(progress);

            // å¦‚æœä»»åŠ¡å·²å®Œæˆï¼Œä¸å†å¯åŠ¨æ¨¡æ‹Ÿå™¨
            if (EnableAutoSimulation &&
                taskSimulator.State != SimulationState.Running &&
                taskSimulator.State != SimulationState.Completed)
            {
                taskSimulator.Start();
            }
        }
    }

    /// <summary>
    /// è®¡ç®—ä»»åŠ¡è·¯å¾„
    /// </summary>
    private PathfindingResult? CalculateTaskPath(TaskListItemDto task)
    {
        try
        {
            if (string.IsNullOrEmpty(task.StartStationCode) || string.IsNullOrEmpty(task.EndStationCode))
                return null;

            // æ ¹æ®StationCodeæŸ¥æ‰¾Station
            var startStation = Stations.FirstOrDefault(s => s.StationCode == task.StartStationCode);
            var endStation = Stations.FirstOrDefault(s => s.StationCode == task.EndStationCode);

            if (startStation == null || endStation == null)
                return null;

            var pathfinder = new AStarPathfinder(Nodes, Edges, Stations);
            return pathfinder.FindPath(startStation.Id, endStation.Id);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"è®¡ç®—ä»»åŠ¡è·¯å¾„å¤±è´¥: {ex.Message}");
            return null;
        }
    }

    /// <summary>
    /// åˆ›å»ºä»»åŠ¡æ¨¡æ‹Ÿå™¨
    /// </summary>
    private AgvSimulator? CreateTaskSimulator(PathfindingResult path, TaskListItemDto task)
    {
        try
        {
            // è·å–AGVä¿¡æ¯ä»¥è·å–é€Ÿåº¦
            var agv = string.IsNullOrEmpty(task.AssignedAgvCode)
                ? null
                : Agvs.FirstOrDefault(a => a.AgvCode == task.AssignedAgvCode);
            // æ•°æ®åº“å­˜å‚¨å•ä½æ˜¯ m/sï¼Œéœ€è¦è½¬æ¢ä¸º cm/sï¼ˆä¹˜ä»¥100ï¼‰
            var speedInMs = agv?.Speed ?? 0.5m; // é»˜è®¤é€Ÿåº¦ 0.5 m/s
            var speed = speedInMs * 100m; // è½¬æ¢ä¸º cm/s

            var config = new AgvSimulationConfig
            {
                Speed = speed,
                UpdateIntervalMs = 50
            };

            var simulator = new AgvSimulator(path, Nodes, Edges, config);

            return simulator;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"åˆ›å»ºä»»åŠ¡æ¨¡æ‹Ÿå™¨å¤±è´¥: {ex.Message}");
            return null;
        }
    }

    /// <summary>
    /// æ¨¡æ‹Ÿå®šæ—¶å™¨æ›´æ–°
    /// </summary>
    private void OnSimulationTimerElapsed(object? sender, ElapsedEventArgs e)
    {
        if (!EnableAutoSimulation) return;

        var needsRender = false;

        foreach (var (taskId, simulator) in _taskSimulators.ToList())
        {
            // è·å–å…³è”çš„ä»»åŠ¡å’Œ AGV
            var task = Tasks.FirstOrDefault(t => t.Id == taskId);
            if (task == null) continue;

            var agv = Agvs.FirstOrDefault(a => a.AgvCode == task.AssignedAgvCode);
            if (agv == null) continue;

            // ğŸ†• æ–°å¢é€»è¾‘ï¼šå¦‚æœ AGV åœ¨ç«™ç‚¹ä¸”ç«™ç‚¹åœ¨è·¯å¾„ä¸Šï¼Œæš‚åœæ¨¡æ‹Ÿ
            if (!string.IsNullOrEmpty(agv.CurrentStationCode))
            {
                if (TryJumpToStationInPath(taskId, simulator, agv.CurrentStationCode, out bool stationInPath))
                {
                    if (stationInPath && simulator.State == SimulationState.Running)
                    {
                        simulator.Pause();  // æš‚åœè‡ªåŠ¨æ¨¡æ‹Ÿ
                        needsRender = true;
                    }
                    continue;  // è·³è¿‡è‡ªåŠ¨æ›´æ–°
                }
            }

            // åŸæœ‰é€»è¾‘ï¼šæ­£å¸¸æ¨¡æ‹Ÿè¿åŠ¨
            if (simulator.State == SimulationState.Running)
            {
                // ä½¿ç”¨é…ç½®çš„é€Ÿåº¦æ¯”ä¾‹è¿›è¡Œæ¨¡æ‹Ÿ
                var speedRatio = SimulationSpeedRatio / 100m;
                simulator.UpdateWithSpeedRatio(speedRatio);
                needsRender = true;
            }
            else if (simulator.State == SimulationState.Paused && string.IsNullOrEmpty(agv.CurrentStationCode))
            {
                // å¦‚æœä¹‹å‰æš‚åœä½†ç°åœ¨ç«™ç‚¹ä¸ºç©ºï¼Œæ¢å¤æ¨¡æ‹Ÿ
                simulator.Resume();
                needsRender = true;
            }
        }

        if (needsRender)
        {
            InvokeAsync(() =>
            {
                // åº”ç”¨è¿½è¸ªé€»è¾‘
                if (TrackingMode != "none" && Guid.TryParse(TrackingMode, out var trackedTaskId))
                {
                    if (_taskSimulators.TryGetValue(trackedTaskId, out var trackedSimulator))
                    {
                        var agvX = (float)trackedSimulator.CurrentPosition.X;
                        var agvY = (float)trackedSimulator.CurrentPosition.Y;

                        // ä½¿å°è½¦ä½ç½®å±…ä¸­
                        _offsetX = -agvX * _scale + _viewWidth / 2f;
                        _offsetY = -agvY * _scale + _viewHeight / 2f;

                        // é‡æ–°æ¸²æŸ“æ•´ä¸ªåœ°å›¾ï¼ˆåŒ…æ‹¬åœ°å›¾å±‚ã€ä»»åŠ¡è·¯å¾„å±‚å’Œç¼©ç•¥å›¾ï¼‰
                        RenderMap();
                    }
                    else
                    {
                        // å¦‚æœè¿½è¸ªçš„ä»»åŠ¡å·²å®Œæˆæˆ–ä¸å­˜åœ¨ï¼Œæ›´æ–°ä»»åŠ¡è·¯å¾„å’Œå°åœ°å›¾
                        RenderTaskPaths();
                        RenderMinimapAgvs();
                    }
                }
                else
                {
                    // ä¸è¿½è¸ªæ—¶æ›´æ–°ä»»åŠ¡è·¯å¾„å’Œå°åœ°å›¾
                    RenderTaskPaths();
                    RenderMinimapAgvs();
                }

                StateHasChanged();
            });
        }
    }

    /// <summary>
    /// åº”ç”¨è¿½è¸ªé€»è¾‘
    /// </summary>
    private void ApplyTracking(Guid taskId)
    {
        if (!_taskSimulators.TryGetValue(taskId, out var simulator))
            return;

        var agvX = (float)simulator.CurrentPosition.X;
        var agvY = (float)simulator.CurrentPosition.Y;

        // ä½¿å°è½¦ä½ç½®å±…ä¸­
        _offsetX = -agvX * _scale + _viewWidth / 2f;
        _offsetY = -agvY * _scale + _viewHeight / 2f;

        // é‡æ–°æ¸²æŸ“æ•´ä¸ªåœ°å›¾ï¼ˆåŒ…æ‹¬åœ°å›¾å±‚ã€ä»»åŠ¡è·¯å¾„å±‚å’Œç¼©ç•¥å›¾ï¼‰
        RenderMap();
    }

    // ===== æ¸²æŸ“æ–¹æ³• =====

    /// <summary>
    /// æ¸²æŸ“ä»»åŠ¡è·¯å¾„
    /// </summary>
    private void RenderTaskPaths()
    {
        if (Map == null || _taskSimulators.Count == 0)
        {
            _taskPathsSvg = string.Empty;
            return;
        }

        // å‡†å¤‡æ¨¡æ‹Ÿæ•°æ®
        var simulatedAgvs = new List<AgvSimulationData>();

        foreach (var (taskId, simulator) in _taskSimulators)
        {
            if (!_taskPathCache.TryGetValue(taskId, out var path))
                continue;

            simulatedAgvs.Add(new AgvSimulationData
            {
                Position = simulator.CurrentPosition,
                StartNodeId = path.NodePath.First(),
                EndNodeId = path.NodePath.Last(),
                PathEdgeIds = path.EdgePath,
                Config = new AgvSimulationConfig
                {
                    AgvSize = 20f,
                    AgvColor = "#2196F3",
                    StartMarkerColor = "#4CAF50",
                    EndMarkerColor = "#F44336",
                    TraveledPathColor = "#2196F3",
                    TraveledPathWidth = 3f,
                    ToEndLineColor = "#9E9E9E",
                    ToEndLineDashArray = "5,5"
                }
            });
        }

        _renderData.SimulatedAgvs = simulatedAgvs;

        _taskPathsSvg = _simulationRenderer.RenderSimulationLayer(
            _renderData,
            _viewWidth,
            _viewHeight,
            _scale,
            _offsetX,
            _offsetY,
            elementScale: _elementScale);
    }

    private void RenderMap()
    {
        if (Map == null) return;

        _mapRenderer = new MapRenderer(RenderOptions);
        _mapSvg = _mapRenderer.Render(
            _renderData,
            _viewWidth,
            _viewHeight,
            _scale,
            _offsetX,
            _offsetY,
            elementScale: _elementScale);

        RenderAgvs();
        RenderTaskPaths();
        RenderMinimap();
    }

    private void RenderAgvs()
    {
        if (Map == null) return;

        var svg = new System.Text.StringBuilder();
        svg.AppendLine($"<svg width=\"{_viewWidth}\" height=\"{_viewHeight}\" xmlns=\"http://www.w3.org/2000/svg\">");

        // æ„å»ºä»»åŠ¡åˆ°æ¨¡æ‹Ÿå™¨çš„æ˜ å°„ï¼ˆAgvCode -> Simulatorï¼‰
        var agvSimulatorMap = new Dictionary<string, (AgvSimulator Simulator, PathfindingResult Path)>();
        foreach (var (taskId, simulator) in _taskSimulators)
        {
            var task = Tasks.FirstOrDefault(t => t.Id == taskId);
            if (task == null || task.TaskStatus != TaskJobStatus.Executing || string.IsNullOrEmpty(task.AssignedAgvCode))
                continue;

            if (!_taskPathCache.TryGetValue(taskId, out var path))
                continue;

            agvSimulatorMap[task.AssignedAgvCode] = (simulator, path);
        }

        // éå†æ‰€æœ‰ AGVï¼Œæ¯ä¸ª AGV åªæ¸²æŸ“ä¸€æ¬¡
        foreach (var agv in Agvs)
        {
            // ç¦»çº¿çš„ AGV ä¸æ˜¾ç¤º
            if (agv.AgvStatus == AgvStatus.Offline)
                continue;

            // ä¼˜å…ˆæ˜¾ç¤ºï¼šå¦‚æœ AGV åœ¨æ¨¡æ‹Ÿå™¨ä¸­ï¼ˆæ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼‰ï¼Œè·³è¿‡ï¼ˆç”±ä»»åŠ¡è·¯å¾„å±‚æ¸²æŸ“ï¼‰
            if (agvSimulatorMap.ContainsKey(agv.AgvCode))
                continue;

            // å¦åˆ™ï¼šä½¿ç”¨ç«™ç‚¹ä½ç½®æ¸²æŸ“
            var station = Stations.FirstOrDefault(s => s.StationCode == agv.CurrentStationCode);
            if (station == null)
                continue;

            var x = (float)station.X * _scale + _offsetX;
            var y = (float)station.Y * _scale + _offsetY;
            var size = 20f * _elementScale;
            var angleInDegrees = (double)agv.PositionAngle; // ä»æ•°æ®åº“è¯»å–çš„æ˜¯åº¦æ•°(0-360)
            var angleInRadians = angleInDegrees * Math.PI / 180.0; // è½¬æ¢ä¸ºå¼§åº¦
            var color = "#4CAF50"; // ç©ºé—²çŠ¶æ€ä½¿ç”¨ç»¿è‰²

            // ä¸‰è§’å½¢é¡¶ç‚¹ï¼ˆæœªæ—‹è½¬æ—¶ï¼Œç®­å¤´æŒ‡å‘å³ä¾§ï¼‰
            var halfSize = size * 0.5f;
            var tipLength = size * 0.8f;

            var p1X = tipLength;
            var p1Y = 0f;
            var p2X = -tipLength * 0.3f;
            var p2Y = -halfSize;
            var p3X = -tipLength * 0.3f;
            var p3Y = halfSize;

            // æ—‹è½¬å¹¶å¹³ç§»
            var cos = (float)Math.Cos(angleInRadians);
            var sin = (float)Math.Sin(angleInRadians);

            float RotateX(float px, float py) => x + px * cos - py * sin;
            float RotateY(float px, float py) => y + px * sin + py * cos;

            var r1X = RotateX(p1X, p1Y);
            var r1Y = RotateY(p1X, p1Y);
            var r2X = RotateX(p2X, p2Y);
            var r2Y = RotateY(p2X, p2Y);
            var r3X = RotateX(p3X, p3Y);
            var r3Y = RotateY(p3X, p3Y);

            // ç»˜åˆ¶å¡«å……çš„ä¸‰è§’å½¢
            svg.AppendLine($"  <path d=\"M{r1X.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)},{r1Y.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)} " +
                $"L{r2X.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)},{r2Y.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)} " +
                $"L{r3X.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)},{r3Y.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)} Z\" " +
                $"fill=\"{color}\" stroke=\"white\" stroke-width=\"2\" />");

            // AGVç¼–å·
            svg.AppendLine($"<text x=\"{x}\" y=\"{y + size + 12}\" text-anchor=\"middle\" font-size=\"12\" fill=\"#333\" font-weight=\"bold\">{agv.AgvCode}</text>");

            // ç”µé‡
            svg.AppendLine($"<text x=\"{x}\" y=\"{y + size + 24}\" text-anchor=\"middle\" font-size=\"10\" fill=\"#666\">{agv.Battery}%</text>");
        }

        svg.AppendLine("</svg>");
        _agvSvg = svg.ToString();

        // æ³¨é‡Šï¼šå°åœ°å›¾çš„ AGV æ¸²æŸ“ç”±è°ƒç”¨æ–¹æ§åˆ¶ï¼Œé¿å…é‡å¤æ¸²æŸ“
        // RenderMinimapAgvs();
    }

    private void RenderMinimap()
    {
        if (Map == null) return;

        // æ¸²æŸ“å°åœ°å›¾åœ°å›¾å±‚
        _minimapMapSvg = _minimapRenderer.RenderMap(
            _renderData,
            MinimapWidth,
            MinimapHeight,
            out _minimapScale,
            out _minimapOffsetX,
            out _minimapOffsetY,
            elementScale: 0.5f);

        // æ¸²æŸ“å°åœ°å›¾ä¸Šçš„AGVï¼ˆç©ºé—²ä¸”åœ¨ç«™ç‚¹çš„AGVï¼‰
        RenderMinimapAgvs();

        // æ¸²æŸ“å°åœ°å›¾è¦†ç›–å±‚ï¼ˆè§†çª—æ¡†ï¼‰
        _minimapOverlaySvg = _minimapRenderer.RenderOverlay(
            minimapWidth: MinimapWidth,
            minimapHeight: MinimapHeight,
            minimapScale: _minimapScale,
            minimapOffsetX: _minimapOffsetX,
            minimapOffsetY: _minimapOffsetY,
            mainViewScale: _scale,
            mainViewOffsetX: _offsetX,
            mainViewOffsetY: _offsetY,
            mainViewWidth: _viewWidth,
            mainViewHeight: _viewHeight,
            agvPosition: null,
            agvSize: 16f,
            agvColor: "#2196F3",
            endPosition: null,
            endMarkerSize: 12f,
            viewportColor: "#FF5722",
            viewportStrokeWidth: 2f,
            viewportDashArray: "5,5");
    }

    private void RenderMinimapAgvs()
    {
        var svg = new System.Text.StringBuilder();
        svg.AppendLine($"<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"{MinimapWidth}\" height=\"{MinimapHeight}\" " +
            $"style=\"position:absolute;top:0;left:0;pointer-events:none;\">");

        // æ„å»ºä»»åŠ¡åˆ°æ¨¡æ‹Ÿå™¨çš„æ˜ å°„ï¼ˆAgvCode -> Simulatorï¼‰
        var agvSimulatorMap = new Dictionary<string, (AgvSimulator Simulator, PathfindingResult Path)>();
        foreach (var (taskId, simulator) in _taskSimulators)
        {
            var task = Tasks.FirstOrDefault(t => t.Id == taskId);
            if (task == null || task.TaskStatus != TaskJobStatus.Executing || string.IsNullOrEmpty(task.AssignedAgvCode))
                continue;

            if (!_taskPathCache.TryGetValue(taskId, out var path))
                continue;

            agvSimulatorMap[task.AssignedAgvCode] = (simulator, path);
        }

        // éå†æ‰€æœ‰ AGVï¼Œæ¯ä¸ª AGV åªæ¸²æŸ“ä¸€æ¬¡
        foreach (var agv in Agvs)
        {
            // ç¦»çº¿çš„ AGV ä¸æ˜¾ç¤º
            if (agv.AgvStatus == AgvStatus.Offline)
                continue;

            // ä¼˜å…ˆæ˜¾ç¤ºï¼šå¦‚æœ AGV åœ¨æ¨¡æ‹Ÿå™¨ä¸­ï¼ˆæ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼‰ï¼Œä½¿ç”¨æ¨¡æ‹Ÿä½ç½®
            if (agvSimulatorMap.TryGetValue(agv.AgvCode, out var simData))
            {
                // æ¸²æŸ“ä»»åŠ¡ç»ˆç‚¹æ ‡è®°
                var endNodeId = simData.Path.NodePath.Last();
                var endNode = Nodes.FirstOrDefault(n => n.Id == endNodeId);
                if (endNode != null)
                {
                    var endX = _minimapOffsetX + (float)endNode.X * _minimapScale;
                    var endY = _minimapOffsetY + (float)endNode.Y * _minimapScale;
                    var radius = 8f;
                    svg.AppendLine($"  <circle cx=\"{endX}\" cy=\"{endY}\" r=\"{radius}\" " +
                        $"fill=\"none\" stroke=\"#F44336\" stroke-width=\"2\" />");
                }

                // æ¸²æŸ“ AGVï¼ˆä½¿ç”¨æ¨¡æ‹Ÿä½ç½®ï¼‰
                var agvX = _minimapOffsetX + (float)simData.Simulator.CurrentPosition.X * _minimapScale;
                var agvY = _minimapOffsetY + (float)simData.Simulator.CurrentPosition.Y * _minimapScale;
                var agvAngle = simData.Simulator.CurrentPosition.Angle;
                var size = 16f;
                var color = "#2196F3"; // æ‰§è¡Œä¸­ä½¿ç”¨è“è‰²

                RenderAgvTriangle(svg, agvX, agvY, agvAngle, size, color);
            }
            else
            {
                // å¦åˆ™ï¼šä½¿ç”¨ç«™ç‚¹ä½ç½®æ¸²æŸ“
                var station = Stations.FirstOrDefault(s => s.StationCode == agv.CurrentStationCode);
                if (station == null)
                    continue;

                var agvX = _minimapOffsetX + (float)station.X * _minimapScale;
                var agvY = _minimapOffsetY + (float)station.Y * _minimapScale;
                var agvAngleInDegrees = (double)agv.PositionAngle;
                var agvAngleInRadians = agvAngleInDegrees * Math.PI / 180.0;
                var size = 16f;
                var color = "#4CAF50"; // ç©ºé—²çŠ¶æ€ç»¿è‰²

                RenderAgvTriangle(svg, agvX, agvY, agvAngleInRadians, size, color);
            }
        }

        svg.AppendLine("</svg>");
        _minimapAgvSvg = svg.ToString();
    }

    /// <summary>
    /// æ¸²æŸ“ AGV ä¸‰è§’å½¢å›¾æ ‡ï¼ˆè¾…åŠ©æ–¹æ³•ï¼‰
    /// </summary>
    private void RenderAgvTriangle(System.Text.StringBuilder svg, float x, float y, double angle, float size, string color)
    {
        var halfSize = size * 0.5f;
        var tipLength = size * 0.8f;

        var p1X = tipLength;
        var p1Y = 0f;
        var p2X = -tipLength * 0.3f;
        var p2Y = -halfSize;
        var p3X = -tipLength * 0.3f;
        var p3Y = halfSize;

        var cos = (float)Math.Cos(angle);
        var sin = (float)Math.Sin(angle);

        float RotateX(float px, float py) => x + px * cos - py * sin;
        float RotateY(float px, float py) => y + px * sin + py * cos;

        var r1X = RotateX(p1X, p1Y);
        var r1Y = RotateY(p1X, p1Y);
        var r2X = RotateX(p2X, p2Y);
        var r2Y = RotateY(p2X, p2Y);
        var r3X = RotateX(p3X, p3Y);
        var r3Y = RotateY(p3X, p3Y);

        svg.AppendLine($"  <path d=\"M{r1X.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)},{r1Y.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)} " +
            $"L{r2X.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)},{r2Y.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)} " +
            $"L{r3X.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)},{r3Y.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)} Z\" " +
            $"fill=\"{color}\" stroke=\"white\" stroke-width=\"1\" />");
    }

    // ===== äº¤äº’æ–¹æ³• =====

    private void ZoomIn()
    {
        _scale *= 1.2f;
        _scale = Math.Min(1f, _scale);
        RenderMap();
    }

    private void ZoomOut()
    {
        _scale *= 0.8f;
        _scale = Math.Max(0.01f, _scale);
        RenderMap();
    }

    private void OnZoomValueChanged(int value)
    {
        _scale = value / 100f;
        _scale = Math.Max(0.01f, Math.Min(1f, _scale));
        RenderMap();
    }

    private void IncreaseElementScale()
    {
        _elementScale = Math.Min(10f, _elementScale + 0.5f);
        RenderMap();
    }

    private void DecreaseElementScale()
    {
        _elementScale = Math.Max(0.5f, _elementScale - 0.5f);
        RenderMap();
    }

    private void FitToScreen()
    {
        if (Map == null) return;
        var mapWidth = (float)Map.Width;
        var mapHeight = (float)Map.Height;
        var scaleX = (_viewWidth - 100) / mapWidth;
        var scaleY = (_viewHeight - 100) / mapHeight;
        _scale = Math.Min(scaleX, scaleY) * 0.9f;
        _offsetX = 50;
        _offsetY = 50;
        RenderMap();
    }

    private void OnWheel(WheelEventArgs e)
    {
        var zoomFactor = e.DeltaY > 0 ? 0.9f : 1.1f;
        _scale *= zoomFactor;
        _scale = Math.Max(0.01f, Math.Min(1f, _scale));
        RenderMap();
    }

    private void OnMouseDown(MouseEventArgs e)
    {
        _isDragging = true;
        _lastMouseX = e.ClientX;
        _lastMouseY = e.ClientY;
    }

    private void OnMouseMove(MouseEventArgs e)
    {
        if (!_isDragging) return;

        var deltaX = (float)(e.ClientX - _lastMouseX);
        var deltaY = (float)(e.ClientY - _lastMouseY);

        _offsetX += deltaX;
        _offsetY += deltaY;

        _lastMouseX = e.ClientX;
        _lastMouseY = e.ClientY;

        // æ‰‹åŠ¨æ‹–åŠ¨åœ°å›¾æ—¶ï¼Œå–æ¶ˆè¿½è¸ªæ¨¡å¼
        if (TrackingMode != "none")
        {
            _ = TrackingModeChanged.InvokeAsync("none");
        }

        RenderMap();
    }

    private void OnMouseUp(MouseEventArgs e)
    {
        _isDragging = false;
    }

    private void OnMouseLeave(MouseEventArgs e)
    {
        _isDragging = false;
    }

    private void OnMinimapClick(MouseEventArgs e)
    {
        if (Map == null) return;

        // è·å–ç‚¹å‡»ä½ç½®ç›¸å¯¹äºç¼©ç•¥å›¾å®¹å™¨çš„åæ ‡
        var clickX = (float)e.OffsetX;
        var clickY = (float)e.OffsetY;

        // è½¬æ¢åˆ°åœ°å›¾åæ ‡
        var mapX = (clickX - _minimapOffsetX) / _minimapScale;
        var mapY = (clickY - _minimapOffsetY) / _minimapScale;

        // è®¡ç®—æ–°çš„åç§»é‡ï¼Œä½¿ç‚¹å‡»ä½ç½®å±…ä¸­
        _offsetX = -mapX * _scale + _viewWidth / 2f;
        _offsetY = -mapY * _scale + _viewHeight / 2f;

        // æ‰‹åŠ¨å¯¼èˆªæ—¶ï¼Œå–æ¶ˆè¿½è¸ªæ¨¡å¼
        if (TrackingMode != "none")
        {
            _ = TrackingModeChanged.InvokeAsync("none");
        }

        RenderMap();
    }

    // ===== ç«™ç‚¹ä½ç½®è¾…åŠ©æ–¹æ³• =====

    /// <summary>
    /// å°è¯•å°†æ¨¡æ‹Ÿå™¨è·³è½¬åˆ°æŒ‡å®šç«™ç‚¹ä½ç½®ï¼ˆå¦‚æœç«™ç‚¹åœ¨è·¯å¾„ä¸Šï¼‰
    /// </summary>
    /// <param name="taskId">ä»»åŠ¡ID</param>
    /// <param name="simulator">AGV æ¨¡æ‹Ÿå™¨</param>
    /// <param name="stationCode">ç«™ç‚¹ç¼–å·</param>
    /// <param name="stationInPath">è¾“å‡ºï¼šç«™ç‚¹æ˜¯å¦åœ¨è·¯å¾„ä¸Š</param>
    /// <returns>æ˜¯å¦æˆåŠŸå¤„ç†</returns>
    private bool TryJumpToStationInPath(
        Guid taskId, 
        AgvSimulator simulator, 
        string stationCode, 
        out bool stationInPath)
    {
        stationInPath = false;

        // 1. æ‰¾åˆ°ç«™ç‚¹å¯¹åº”çš„èŠ‚ç‚¹ID
        var station = Stations.FirstOrDefault(s => s.StationCode == stationCode);
        if (station == null)
            return false;

        // 2. è·å–ä»»åŠ¡è·¯å¾„
        if (!_taskPathCache.TryGetValue(taskId, out var path))
            return false;

        // 3. æ£€æŸ¥ç«™ç‚¹çš„èŠ‚ç‚¹æ˜¯å¦åœ¨è·¯å¾„ä¸Š
        var nodeIndex = path.NodePath.FindIndex(nodeId => nodeId == station.NodeId);
        if (nodeIndex < 0)
        {
            stationInPath = false;
            return true;  // ç«™ç‚¹ä¸åœ¨è·¯å¾„ä¸Šï¼Œä½†å¤„ç†æˆåŠŸ
        }

        stationInPath = true;

        // 4. è®¡ç®—åˆ°è¯¥èŠ‚ç‚¹çš„è¿›åº¦ç™¾åˆ†æ¯”
        var progressToNode = CalculateProgressToNode(path, nodeIndex);

        // 5. è·³è½¬åˆ°è¯¥ä½ç½®
        simulator.JumpToProgress(progressToNode);

        return true;
    }

    /// <summary>
    /// è®¡ç®—åˆ°æŒ‡å®šèŠ‚ç‚¹çš„è¿›åº¦ç™¾åˆ†æ¯”
    /// </summary>
    private decimal CalculateProgressToNode(PathfindingResult path, int nodeIndex)
    {
        if (nodeIndex <= 0)
            return 0;

        if (nodeIndex >= path.NodePath.Count - 1)
            return 100;

        // æ„å»ºè¾¹å­—å…¸
        var edgeDict = Edges.ToDictionary(e => e.Id);

        // è®¡ç®—åˆ°è¯¥èŠ‚ç‚¹çš„ç´¯ç§¯è·ç¦»
        decimal distanceToNode = 0;
        for (int i = 0; i < nodeIndex; i++)
        {
            var edgeId = path.EdgePath[i];
            if (edgeDict.TryGetValue(edgeId, out var edge))
            {
                distanceToNode += edge.Distance;
            }
        }

        // è½¬æ¢ä¸ºç™¾åˆ†æ¯”
        var progress = (distanceToNode / path.TotalDistance) * 100m;
        return Math.Min(100, Math.Max(0, progress));
    }
}
